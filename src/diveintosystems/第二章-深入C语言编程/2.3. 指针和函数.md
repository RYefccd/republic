
Pointer parameters provide a mechanism through which functions can modify argument values. The commonly used **pass by pointer** pattern uses a pointer function parameter that _gets the value of the address of some storage location_ passed to it by the caller. For example, the caller could pass the address of one of its local variables. By dereferencing the pointer parameter inside the function, the function can modify the value at the storage location to which it points.

指针参数提供了一种机制，函数可以通过该机制修改参数值。常用的**指针传递**(**pass by pointer**)模式使用指针函数参数，该参数获取调用者传递给它的 _某个存储位置的地址值_。例如，调用者可以传递其局部变量之一的地址。通过在函数内部取消引用(解引用)指针参数，函数可以修改其指向的存储位置处的值。

We have already seen similar functionality with array parameters, where an array function parameter gets the value of the base address of the passed array (the parameter refers to the same set of array elements as its argument), and the function can modify the values stored in the array. In general, this same idea can be applied by passing pointer parameters to functions that point to the memory locations in the caller’s scope.

我们已经看到了与数组参数类似的功能，其中数组函数参数获取传递数组的基地址的值（该参数引用与其参数相同的数组元素集），并且该函数可以修改存储的值在数组中。一般来说，可以通过将指针参数传递给指向调用者作用域中的内存位置的函数来应用相同的想法。

|     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| --- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
|     | Pass by Value<br><br>All arguments in C are passed by value and follow pass-by-value semantics: the parameter gets a copy of its argument value, and modifying the parameter’s value does not change its argument’s value. When passing base type values, like the value of an `int` variable, the function parameter gets a copy of its argument value (the specific `int` value), and changing the value stored in the parameter cannot change the value stored in its argument.<br><br>In the pass-by-pointer pattern, the parameter still gets the value of its argument, but it is passed _the value of an address_. Just like in passing base types, changing a pointer parameter’s value will not change its argument’s value (that is, assigning the parameter to point to a different address will not change the argument’s address value). However, by dereferencing a pointer parameter, the function can change the contents of memory that both the parameter and its argument refer to; through a pointer parameter, a function can modify a variable that is visible to the caller after the function returns. |

> [!NOTE] Pass by Value
> C 中的所有参数均按值传递并遵循按值传递语义：形参获取其实参值的副本，并且修改参数的值不会更改其参数的值。当传递基本类型值时，例如变量的值`int`，函数参数会获取其参数值(特定值)的副本 `int`，并且更改存储在参数中的值无法更改存储在其参数中的值。  
> 在指针传递(pass-by-pointer)模式中，形参参数仍然获取其实参参数的值，但传递的是 _地址的值_。就像传递基类型一样，更改指针参数的值不会更改其参数的值（即，将参数分配为指向不同的地址不会更改参数的地址值）。但是，通过取消引用指针参数，函数可以更改参数及其实参所引用的内存内容；通过指针参数，函数可以进行变量内容修改，即使当前函数返回以后，这些修改调用者函数仍然可见。  


Here are the steps for implementing and calling a function with a pass by pointer parameter, with example code snippets showing each step:  

以下是实现和调用带有传递指针参数的函数的步骤，每一步的代码示例如下：  

1. Declare the function parameter to be a pointer to the variable type:
1. 将函数参数声明为指向变量类型的指针：
    
    ```c
    /* input: an int pointer that stores the address of a memory
     *        location that can store an int value (it points to an int)
     */
    int change_value(int *input) {
    ```
    
2. When making the function call, pass in the address of a variable as the argument:  
2. 进行函数调用时，传入变量的地址作为参数：
    
    ```c
    int x;
    change_value(&x);
    ```
    
    In the preceding example, since the parameter’s type is `int *`, the address passed must be the address of an `int` variable.
	在前面的示例中，由于参数的类型是`int *`，因此必须传递`int`类型变量的地址。
    
3. In the body of the function, dereference the pointer parameter to change the argument’s value:  
3. 在函数体内，取消引用指针参数以更改参数的值： 
    
    ```c
    *input = 100;  // the location input points to (x's memory) is assigned 100
    ```
    

Next, let’s examine a [larger example program](https://diveintosystems.org/book/C2-C_depth/_attachments/passbypointer.c):  
接下来，让我们检查一个[更大的示例程序](https://diveintosystems.org/book/C2-C_depth/_attachments/passbypointer.c)：

```c
#include <stdio.h>

int change_value(int *input);

int main(void) {
    int x;
    int y;

    x = 30;
    y = change_value(&x);
    printf("x: %d y: %d\n", x, y);  // prints x: 100 y: 30

    return 0;
}

/*
 * changes the value of the argument
 *     input: a pointer to the value to change
 *     returns: the original value of the argument
 */
int change_value(int *input) {
    int val;

    val = *input; /* val gets the value input points to */

    if (val < 100) {
        *input = 100;  /* the value input points to gets 100 */
    } else {
        *input =  val * 2;
    }

    return val;
}
```

When run, the output is:  
运行时，输出为：

	x: 100 y: 30

[Figure 1](https://diveintosystems.org/book/C2-C_depth/pointers_functions.html#FigPassPointer) shows what the call stack looks like before executing the return in `change_value`.  
[图 1](https://diveintosystems.org/book/C2-C_depth/pointers_functions.html#FigPassPointer)显示了在 中执行 return 之前的调用堆栈`change_value`。

![The input parameter to change_value stores the address of main’s 'x' variable.](https://diveintosystems.org/book/C2-C_depth/_images/passbypointer.png)

Figure 1. A snapshot of the call stack prior to returning from change_value.
图 1. 从 change_value 返回之前的调用栈快照。

The input parameter gets a copy of the value of its argument (the address of `x`). The value of `x` is 30 when the function call is made. Inside the `change_value` function, the parameter is dereferenced to assign the value 100 to the memory location pointed to by the parameter (`*input = 100;`, meaning "the location `input` points to gets the value 100"). Since the parameter stores the address of a local variable in the `main` function’s stack frame, through dereferencing the parameter, the value stored in the caller’s local variable can be changed. When the function returns, the argument’s value reflects the change made to it through the pointer parameter (the value of `x` in `main` was changed to 100 by the `change_value` function through its `input` parameter).  
输入参数获取其参数值的副本(`x`的地址)。在main函数调用时`x`的值为30。在 `change_value`函数内部，参数被解引用(取消引用，取地址对应的值)，将值 100 分配给参数指向的内存位置(`*input = 100;` 意思是“`input`指向的位置设置为值 100”)。由于参数存储`main`函数堆栈帧中局部变量的地址，因此通过取消引用参数，可以更改调用者局部变量中存储的值。当函数返回时，参数的值反映了通过指针参数对其所做的更改(`main`函数中的x的值被`change_value`函数通过`input`参数修改为 100)。