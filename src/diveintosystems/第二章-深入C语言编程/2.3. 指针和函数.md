
Pointer parameters provide a mechanism through which functions can modify argument values. The commonly used **pass by pointer** pattern uses a pointer function parameter that _gets the value of the address of some storage location_ passed to it by the caller. For example, the caller could pass the address of one of its local variables. By dereferencing the pointer parameter inside the function, the function can modify the value at the storage location to which it points.

指针参数提供了一种机制，函数可以通过该机制修改参数值。常用的**指针传递**(**pass by pointer**)模式使用指针函数参数，该参数获取调用者传递给它的 _某个存储位置的地址值_。例如，调用者可以传递其局部变量之一的地址。通过在函数内部取消引用(解引用)指针参数，函数可以修改其指向的存储位置处的值。

We have already seen similar functionality with array parameters, where an array function parameter gets the value of the base address of the passed array (the parameter refers to the same set of array elements as its argument), and the function can modify the values stored in the array. In general, this same idea can be applied by passing pointer parameters to functions that point to the memory locations in the caller’s scope.

我们已经看到了与数组参数类似的功能，其中数组函数参数获取传递数组的基地址的值（该参数引用与其参数相同的数组元素集），并且该函数可以修改存储的值在数组中。一般来说，可以通过将指针参数传递给指向调用者作用域中的内存位置的函数来应用相同的想法。

|     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| --- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
|     | Pass by Value<br><br>All arguments in C are passed by value and follow pass-by-value semantics: the parameter gets a copy of its argument value, and modifying the parameter’s value does not change its argument’s value. When passing base type values, like the value of an `int` variable, the function parameter gets a copy of its argument value (the specific `int` value), and changing the value stored in the parameter cannot change the value stored in its argument.<br><br>In the pass-by-pointer pattern, the parameter still gets the value of its argument, but it is passed _the value of an address_. Just like in passing base types, changing a pointer parameter’s value will not change its argument’s value (that is, assigning the parameter to point to a different address will not change the argument’s address value). However, by dereferencing a pointer parameter, the function can change the contents of memory that both the parameter and its argument refer to; through a pointer parameter, a function can modify a variable that is visible to the caller after the function returns. |

> [!NOTE] Pass by Value
> C 中的所有参数均按值传递并遵循按值传递语义：参数获取其参数值的副本，并且修改参数的值不会更改其参数的值。当传递基本类型值时，例如变量的值`int`，函数参数会获取其参数值(特定值)的副本 `int`，并且更改存储在参数中的值无法更改存储在其参数中的值。  
> 在指针传递(pass-by-pointer)模式中，参数仍然获取其参数的值，但传递的是_地址的值_。就像传递基类型一样，更改指针参数的值不会更改其参数的值（即，将参数分配为指向不同的地址不会更改参数的地址值）。但是，通过取消引用指针参数，函数可以更改参数及其实参所引用的内存内容；通过指针参数，函数可以进行变量内容修改，即使当前函数返回以后，这些修改调用者函数仍然可见。  


Here are the steps for implementing and calling a function with a pass by pointer parameter, with example code snippets showing each step:

1. Declare the function parameter to be a pointer to the variable type:
    
    ```c
    /* input: an int pointer that stores the address of a memory
     *        location that can store an int value (it points to an int)
     */
    int change_value(int *input) {
    ```
    
2. When making the function call, pass in the address of a variable as the argument:
    
    ```c
    int x;
    change_value(&x);
    ```
    
    In the preceding example, since the parameter’s type is `int *`, the address passed must be the address of an `int` variable.
    
3. In the body of the function, dereference the pointer parameter to change the argument’s value:
    
    ```c
    *input = 100;  // the location input points to (x's memory) is assigned 100
    ```
    

Next, let’s examine a [larger example program](https://diveintosystems.org/book/C2-C_depth/_attachments/passbypointer.c):

```c
#include <stdio.h>

int change_value(int *input);

int main(void) {
    int x;
    int y;

    x = 30;
    y = change_value(&x);
    printf("x: %d y: %d\n", x, y);  // prints x: 100 y: 30

    return 0;
}

/*
 * changes the value of the argument
 *     input: a pointer to the value to change
 *     returns: the original value of the argument
 */
int change_value(int *input) {
    int val;

    val = *input; /* val gets the value input points to */

    if (val < 100) {
        *input = 100;  /* the value input points to gets 100 */
    } else {
        *input =  val * 2;
    }

    return val;
}
```

When run, the output is:

x: 100 y: 30

[Figure 1](https://diveintosystems.org/book/C2-C_depth/pointers_functions.html#FigPassPointer) shows what the call stack looks like before executing the return in `change_value`.

![The input parameter to change_value stores the address of main’s 'x' variable.](https://diveintosystems.org/book/C2-C_depth/_images/passbypointer.png)

Figure 1. A snapshot of the call stack prior to returning from change_value.

The input parameter gets a copy of the value of its argument (the address of `x`). The value of `x` is 30 when the function call is made. Inside the `change_value` function, the parameter is dereferenced to assign the value 100 to the memory location pointed to by the parameter (`*input = 100;`, meaning "the location `input` points to gets the value 100"). Since the parameter stores the address of a local variable in the `main` function’s stack frame, through dereferencing the parameter, the value stored in the caller’s local variable can be changed. When the function returns, the argument’s value reflects the change made to it through the pointer parameter (the value of `x` in `main` was changed to 100 by the `change_value` function through its `input` parameter).