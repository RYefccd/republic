### 2.9.3. The `void *` Type and Type Recasting

The C type `void *` represents a generic pointer — a pointer to any type, or a pointer to an unspecified type. C allows for a generic pointer type because memory addresses on a system are always stored in the same number of bytes (e.g., addresses are four bytes on 32-bit systems and eight bytes on 64-bit systems). As a result, every pointer variable requires the same number of storage bytes, and because they’re all the same size, the compiler can allocate space for a `void *` variable without knowing the type it points to. Here’s an example:  
C 类型`void *`表示通用指针——指向任何类型的指针，或指向未指定类型的指针。 C 允许通用指针类型，因为系统上的内存地址始终存储在相同数量的字节中(例如，地址在 32 位系统上为 4 个字节，在 64 位系统上为 8 个字节)。因此，每个指针变量都需要相同数量的存储字节，并且由于它们的大小相同，因此编译器可以在 `void *`不知道变量指向的类型的情况下为变量分配空间。这是一个例子：

```c
void *gen_ptr;
int x;
char ch;

gen_ptr = &x;  // gen_ptr can be assigned the address of an int
gen_ptr = &ch; // or the address of a char (or the address of any type)
```

Typically, programmers do not declare variables of type `void *` as in the preceding example. Instead, it’s commonly used to specify generic return types from functions or generic parameters to functions. The `void *` type is often used as a return type by functions that return newly allocated memory that can be used to store any type (e.g., `malloc`). It’s also used as a function parameter for functions that can take any type of value. In this case, individual calls to the function pass in a pointer to some specific type, which can be passed to the function’s `void *` parameter because it can store the address of any type.

通常，程序员不会`void *`像前面的示例那样声明类型变量。相反，它通常用于指定函数的通用返回类型或函数的通用参数。该`void *`类型通常被函数用作返回类型，这些函数返回新分配的内存，该内存可用于存储任何类型（例如，`malloc`）。它还用作可以采用任何类型值的函数的函数参数。在这种情况下，对函数的单独调用会传入指向某种特定类型的指针，该指针可以传递给函数的`void *`参数，因为它可以存储任何类型的地址。

Because `void *` is a generic pointer type, it cannot be directly dereferenced — the compiler does not know the size of memory that the address points to. For example, the address could refer to an `int` storage location of four bytes or it could refer to a `char` storage location in memory of one byte. Therefore, the programmer must explicitly **recast** the `void *` pointer to a pointer of a specific type before dereferencing it. Recasting tells the compiler the specific type of pointer variable, allowing the compiler to generate the correct memory access code for pointer dereferences.

因为`void *`是通用指针类型，所以不能直接取消引用——编译器不知道地址指向的内存大小。例如，地址可以指代`int`四个字节的存储位置，或者可以指`char`代存储器中的一个字节的存储位置。因此，程序员必须在取消引用之前显式地 将指针**重新转换**`void *`为特定类型的指针。重铸告诉编译器指针变量的具体类型，允许编译器为指针解引用生成正确的内存访问代码。

Here are two examples of `void *` use:  
下面是两个`void *`使用示例：

1. A call to `malloc` recasts its `void *` return type to the specific pointer type of the variable used to store its returned heap memory address:  
1. 调用将`malloc`其`void *`返回类型重新转换为用于存储返回的堆内存地址的变量的特定指针类型：
    
    ```c
    int *array;
    char *str;
    
    array = (int *)malloc(sizeof(int) * 10); // recast void * return value
    str = (char *)malloc(sizeof(char) * 20);
    
    *array = 10;
    str[0] = 'a';
    ```
    
2. Students often encounter the `void *` when [creating threads](https://diveintosystems.org/book/C14-SharedMemory/posix.html#_hello_threading_writing_your_first_multithreaded_program). Using a `void *` parameter type in a thread function allows the thread to take any type of application-specific pointer. The `pthread_create` function has a parameter for the thread main function and a `void *` parameter for the argument value that it passes to the thread main function that the newly created thread will execute. The use of the `void *` parameter makes `pthread_create` a generic thread creation function; it can be used to point to any type of memory location. For a specific program that calls `pthread_create`, the programmer knows the type of the argument passed to the `void *` parameter, so the programmer must recast it to its known type before dereferencing it. In this example, suppose that the address passed to the `args` parameter contains the address of an integer variable:  
2. 创建线程的时候经常会遇到 void *。在线程函数中使用 `void *` 参数类型允许线程采用任何类型的应用程序特定指针。 `pthread_create` 函数有一个用于线程主函数的参数和一个用于传递给新创建的线程将执行的线程主函数的参数值的 `void *` 参数。 `void *`参数的使用使得 `pthread_create` 成为一个通用的线程创建函数；它可用于指向任何类型的内存位置。对于调用  `pthread_create` 的特定程序，程序员知道传递给 `void *` 参数的实参类型，因此程序员必须在取消引用它之前将其重新转换为其已知类型。在此示例中，假设传递给 args 参数的地址包含整型变量的地址： 
    
    ```c
    /*
     * an application-specific pthread main function
     * must have this function prototype: int func_name(void *args)
     *
     * any given implementation knows what type is really passed in
     *  args: pointer to an int value
     */
    int my_thr_main(void *args) {
        int num;
    
        // first recast args to an int *, then dereference to get int value
        num = *((int *)args);  // num gets 6
        ...
    }
    
    int main(void) {
        int ret, x;
        pthread_t tid;
    
        x = 6;
        // pass the address of int variable (x) to pthread_create's void * param
        // (we recast &x as a (void *) to match the type of pthread_create's param)
        ret = pthread_create(&tid, NULL,
                             my_thr_main,    // a thread main function
                             (void *)(&x));  // &x will be passed to my_thr_main
        // ...
    ```