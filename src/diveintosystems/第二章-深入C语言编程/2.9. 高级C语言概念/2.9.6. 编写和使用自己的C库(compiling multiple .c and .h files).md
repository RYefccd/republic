### 2.9.6. 编写和使用自己的C库

Programmers typically divide large C programs into separate **modules** (i.e., separate `.c` files) of related functionality. Definitions shared by more than one module are put in header files (`.h` files) that are included by the modules that need them. Similarly, C library code is also implemented in one or more modules (`.c` files) and one or more header files (`.h` files). C programmers often implement their own C libraries of commonly used functionality. By writing a library, a programmer implements the functionality once, in the library, and then can use this functionality in any subsequent C program that they write.  
程序员通常将大型 C 程序划分为相关功能的单独**模块**（即单独的`.c`文件）。多个模块共享的定义被放入头文件(`.h`文件)中，这些文件由需要它们的模块包含。同样，C 库代码也在一个或多个模块(`.c`文件)和一个或多个头文件(`.h`文件)中实现。 C 程序员经常实现自己的常用功能 C 库。通过编写库，程序员可以在库中实现该功能一次，然后可以在他们编写的任何后续 C 程序中使用该功能。

In the [Using, Compiling, and Linking Libraries](https://diveintosystems.org/book/C2-C_depth/advanced_libraries.html#_c_link_load_) section, we describe how to use, compile, and link C library code into C programs. In this section, we discuss how to write and use your own libraries in C. What we present here also applies to structuring and compiling larger C programs composed of multiple C source and header files.  
在[编译, 链接和C库使用](2.9.5.%20编译,%20链接和C库使用.md)部分中，我们介绍了如何使用、编译 C 库代码并将其链接到 C 程序中。在本节中，我们讨论如何用 C 语言编写和使用您自己的库。我们在这里介绍的内容也适用于构造和编译由多个 C 源文件和头文件组成的大型 C 程序。

To create a library in C:

1. Define an interface to the library in a header (`.h`) file. This header file must be included by any program that wants to use the library.
    
2. Create an implementation of the library in one or more `.c` files. This set of function definitions implement the library’s functionality. Some functions may be interface functions that users of the library will call, and others may be internal functions that cannot be called by users of the library (internal functions are part of good modular design of the library’s implementation).
    
3. Compile a binary form of the library that can be linked into programs that use the library.
    
要在 C 中创建库：

1. 在头文件 (`.h`) 中定义库的接口。任何想要使用该库的程序都必须包含该头文件。
2. 在一个或多个`.c`文件中创建该库的实现。这组函数定义实现了库的功能。有些函数可能是库的用户将调用的接口函数，而其他函数可能是库的用户无法调用的内部函数(内部函数是库实现的良好模块化设计的一部分)。
3. 编译该库的二进制形式，该库可以链接到使用该库的程序中。

The binary form of a library could be directly built from its source file(s) as part of compiling the application code that uses the library. This method compiles the library files into `.o` files and statically links them into the binary executable. Including libraries this way often applies to library code that you write for your own use (since you have access to its `.c` source files), and it’s also the method to build an executable from multiple `.c` modules.  
库的二进制形式可以直接从其源文件构建，作为编译使用该库的应用程序代码的一部分。此方法将库文件编译为`.o`文件并将它们静态链接到二进制可执行文件中。以这种方式包含库通常适用于您为自己使用而编写的库代码(因为您可以访问其`.c`源文件)，并且它也是从多个`.c`模块构建可执行文件的方法。

Alternatively, a library could be compiled into a binary archive (`.a`) or a shared object (`.so`) file for programs that want to use the library. In these cases, users of the library often will not have access to the library’s C source code files, and thus they are not able to directly compile the library code with application code that uses it. When a program uses such a precompiled library (e.g., a `.a` or `.so`), the library’s code must be explicitly linked into the executable file using `gcc`'s `-l` command line option.  
或者，可以将库编译为二进制存档 (`.a`) 或共享对象 (`.so`) 文件，以供想要使用该库的程序使用。在这些情况下，库的用户通常无法访问库的 C 源代码文件，因此他们无法直接使用使用库代码的应用程序代码来编译库代码。当程序使用此类预编译库(例如`.a`或`.so`)时，必须使用`gcc`的`-l`命令行选项将库的代码显式链接到可执行文件中。

We focus our detailed discussion of writing, compiling, and linking library code on the case in which the programmer has access to individual library modules (either the `.c` or `.o` files). This focus also applies to designing and compiling large C programs that are divided into multiple `.c` and `.h` files. We briefly show commands for building archive and shared object forms of libraries. More information about building these types of library files is available in the `gcc` documentation, including the man pages for `gcc` and `ar`.  
我们将详细讨论编写、编译和链接库代码的情况，其中程序员可以访问各个库模块(`.c`或`.o`文件)。这一重点也适用于设计和编译分为多个`.c`和`.h`文件的大型 C 程序。我们简要展示了用于构建库的存档和共享对象形式的命令。有关构建这些类型的库文件的更多信息，请参阅`gcc`文档，包括`gcc`和`ar`的手册页。

#### 库详细信息示例(Library Details by Example)

In the following, we show some examples of creating and using your own libraries.  
下面，我们将展示一些创建和使用您自己的库的示例。

**Define the library interface:**
**定义库接口：**

Header files (`.h` file) are text files that contain C function prototypes and other definitions — they represent the interface of a library. A header file must be included in any application that intends to use the library. For example, the C standard library header files are usually stored in `/usr/include/` and can be viewed with an editor:  
头文件(`.h` 文件)是包含 C 函数原型和其他定义的文本文件——它们代表库的接口。任何想要使用该库的应用程序中都必须包含头文件。例如，C标准库头文件通常存储在`/usr/include/`中，可以使用编辑器查看：

```bash
$ vi /usr/include/stdio.h
```

Here’s an [example header file (`mylib.h`)](https://diveintosystems.org/book/C2-C_depth/_attachments/mylib.h) from a library that contains some definitions for users of the library.  
下面是来自库的[示例头文件 (`mylib.h`)](https://diveintosystems.org/book/C2-C_depth/_attachments/mylib.h)，其中包含库用户的一些定义。

```c
#ifndef _MYLIB_H_
#define _MYLIB_H_

// a constant definition exported by library:
#define MAX_FOO  20

// a type definition exported by library:
struct foo_struct {
    int x;
    float y;
};

// a global variable exported by library
// "extern" means that this is not a variable declaration,
// but it defines that a variable named total_times of type
// int exists in the library implementation and is available
// for use by programs using the library.
// It is unusual for a library to export global variables
// to its users, but if it does, it is important that
// extern appears in the definition in the .h file
extern int total_times;

// a function prototype for a function exported by library:
// extern means that this function definition exists
// somewhere else.
/*
 * This function returns the larger of two float values
 *  y, z: the two values
 *  returns the value of the larger one
 */
extern float bigger(float y, float z);

#endif
```

Header files typically have special "boilerplate" code around their contents:  
头文件通常在其内容周围有特殊的“样板”代码：

```c
#ifndef

// header file contents

#endif
```

This boilerplate code ensures that the compiler’s preprocessor only includes the contents of `mylib.h` exactly once in any C file that includes it. It is important to include `.h` file contents only once to avoid duplicate definition errors at compile time. Similarly, if you forget to include a `.h` file in a C program that uses the library, the compiler will generate an `undefined symbol` warning.  
此样板代码可确保编译器的预处理器仅在包含`mylib.h`的任何 C 文件中包含该内容一次。仅包含一次`.h`文件内容很重要，以避免编译时出现重复定义错误。同样，如果您忘记在使用该库的 C 程序中包含`.h`文件，编译器将生成`未定义符号`(`undefined symbol`)警告。

The comments in the `.h` file are part of the interface to the library, written for users of the library. These comments should be verbose, explaining definitions and describing what each library function does, what parameters values it takes, and what it returns. Sometimes a `.h` file will also include a top-level comment describing how to use the library.  
`.h` 文件中的注释是库接口的一部分，是为库用户编写的。这些注释应该很详细，解释定义并描述每个库函数的作用、它采用的参数值以及它返回的内容。有时`.h`文件还会包含描述如何使用该库的顶级注释。

The keyword **extern** before the global variable definition and function prototype means that these names are defined somewhere else. It is particularly important to include `extern` before any global variables that the library exports, as it distinguishes a name and type definition (in the `.h` file) from a variable declaration in the library’s implementation. In the previous example, the global variable is declared exactly once inside the library, but it’s exported to library users through its `extern` definition in the library’s `.h` file.  
全局变量定义和函数原型之前的关键字**extern**意味着这些名称是在其他地方定义的。在库导出的任何全局变量之前包含“extern”尤其重要，因为它将名称和类型定义(在`.h`文件中)与库实现中的变量声明区分开来。在前面的示例中，全局变量在库内仅声明一次，但它通过库的`.h`文件中的`extern`定义导出给库用户。

**Implement the library functionality:**  
**实现库功能：**

Programmers implement libraries in one or more `.c` files (and sometimes internal `.h` files). The implementation includes definitions of all the functions' prototypes in the `.h` file as well as other functions that are internal to its implementation. These internal functions are often defined with the keyword `static`, which scopes their availability to the module (`.c` file) in which they are defined. The library implementation should also include variable definitions for any `extern` global variable declarations in the `.h` file. Here’s [an example library implementation (`mylib.c`)](https://diveintosystems.org/book/C2-C_depth/_attachments/mylib.c):  
程序员在一个或多个`.c`文件(有时是内部`.h`文件)中实现库。该实现包括`.h`文件中所有函数原型的定义以及其实现内部的其他函数。这些内部函数通常使用关键字`static`定义，这将它们的可见性限制在定义它们的模块(`.c`文件)内。库实现还应包括`.h`文件中任何`extern`全局变量声明的变量定义。这是[示例库实现 (`mylib.c`)](https://diveintosystems.org/book/C2-C_depth/_attachments/mylib.c)：

```c
#include <stdlib.h>

// Include the library header file if the implementation needs
// any of its definitions (types or constants, for example.)
// Use " " instead of < > if the mylib.h file is not in a
// default  library path with other standard library header
// files (the usual case for library code you write and use.)
#include "mylib.h"

// declare the global variable exported by the library
int total_times = 0;

// include function definitions for each library function:
float bigger(float y, float z) {
    total_times++;
    if (y > z) {
        return y;
    }
    return z;
}
```

**Create a binary form of the library:**  
**创建库的二进制形式：**

To create a binary form of the library (a `.o` file), compile with the `-c` option:  
要创建库的二进制形式(`.o`文件)，请使用以下 `-c`选项进行编译：

```bash
$ gcc -o mylib.o -c mylib.c
```

One or more `.o` files can build an archive (`.a`) or shared object (`.so`) version of the library.  
一个或多个`.o`文件可以构建库的归档 ( `.a`) 或共享对象 ( `.so`) 版本。

- To build a static library use the archiver (`ar`):  
  要构建静态库，请使用归档器 (`ar`)：
```bash
ar -rcs libmylib.a mylib.o
```

- To build a dynamically linked library, the `mylib.o` object file(s) in the library must be built with **position independent code** (using `-fPIC`). A `libmylib.so` shared object file can be created from `mylib.o` by specifying the `-shared` flag to `gcc`:  
  要构建动态链接库，`mylib.o`库中的目标文件必须使用与**位置无关的代码**构建(使用`-fPIC`)。可以通过指定 `-shared` 标志来`libmylib.so`创建共享对象文件 ：`mylib.o``-shared``gcc`
  要构建动态链接库，`mylib.o`目标文件必须使用**位置无关代码**(使用`-fPIC`)构建。
  通过将`gcc`的标志指定为`-shared`，可以从`mylib.o`创建`libmylib.so`共享对象文件：
    
```bash
gcc -fPIC -o mylib.o -c mylib.c
gcc -shared -o libmylib.so mylib.o
```

- Shared object and archive libraries are often built from multiple `.o` files, for example (remember that `.o` for dynamically linked libraries need to be built using the `-fPIC` flag):  
  例如，共享对象和归档库通常是从多个`.o`文件构建的(请记住，动态链接库的`.o`需要使用`-fPIC`标志构建)：

```bash
gcc -shared -o libbiglib.so file1.o file2.o file3.o file4.o
ar -rcs libbiglib.a file1.o file2.o file3.o file4.o
```

**Use and link the library:**  
**使用并链接库：**  

In other `.c` files that use this library:

1. `#include` its header file, and
    
2. explicitly link in the implementation (`.o` file) during compilation.
    

`.c`在使用该库的其他文件中：
1. `#include`它的头文件
2. 在编译期间显式链接到实现(`.o`文件)中。

After including the library header file, your code then can call the library’s functions (e.g., in [`myprog.c`](https://diveintosystems.org/book/C2-C_depth/_attachments/myprog.c)):  
包含库头文件后，您的代码就可以调用库的函数(例如，在 中[`myprog.c`](https://diveintosystems.org/book/C2-C_depth/_attachments/myprog.c))：  

```c
#include <stdio.h>
#include "mylib.h"   // include library header file

int main(void) {
    float val1, val2, ret;
    printf("Enter two float values: ");
    scanf("%f%f", &val1, &val2);
    ret = bigger(val1, val2);   // use a library function
    printf("%f is the biggest\n", ret);

    return 0;
}
```


> [!NOTE] `#include` syntax and the preprocessor
> Note that the `#include` syntax to include `mylib.h` is different from the syntax to include `stdio.h`. This is because `mylib.h` is not located with the header files from standard libraries. The preprocessor has default places it looks for standard header files. When including a file with the `<file.h>` syntax instead of the `"file.h"` syntax, the preprocessor searches for the header file in those standard places.
> 
> When `mylib.h` is included inside double quotes, the preprocessor first looks in the current directory for the `mylib.h` file, and then other places that you need to explicitly tell it to look, by specifying an include path (`-I`) to `gcc`. For example, if the header file is in the `/home/me/myincludes` directory (and not in the same directory as the `myprog.c` file), then the path to this directory must be specified in the `gcc` command line for the preprocessor to find the `mylib.h` file:
> 
> ```bash
> $ gcc -I/home/me/myincludes -c myprog.c
> ```

#### 常见编译命令(从源码, 目标文件或库文件中构建执行程序)

- To compile a program (`myprog.c`) that uses the library (`mylib.o`) into a binary executable:  
  要将使用库 (`mylib.o`) 的程序 (`myprog.c`) 编译为二进制可执行文件：
    
	```bash
	    $ gcc -o myprog myprog.c mylib.o
	```
    
- Or, if the library’s implementation files are available at compile time, then the program can be built directly from the program and library `.c` files:  
  或者，如果库的实现文件在编译时可用，则可以直接从程序和库 `.c` 文件构建程序：
    
	```
	    $ gcc -o myprog myprog.c mylib.c
	```
    
- Or, if the library is available as an archive or shared object file, then it can be linked in using `-l`, (`-lmylib`: note that the library name is `libmylib.[a,so]`, but only the `mylib` part is included in the `gcc` command line):  
  或者，如果该库可作为归档或共享对象文件使用，则可以使用`-l`链接它，(`-lmylib`：请注意，库名称是`libmylib.[a,so]`，但是仅`mylib`部分包含在`gcc`命令行中)：
    
	```
	    $ gcc -o myprog myprog.c -L. -lmylib
	```
    
The `-L.` option specifies the path to the `libmylib.[so,a]` files (the `.` after the `-L` indicates that it should search the current directory). By default, `gcc` will dynamically link a library if it can find a `.so` version. See the [Using C libraries section](https://diveintosystems.org/book/C2-C_depth/advanced_libraries.html#_c_link_load_) for more information about linking and link paths.
`-L.`选项指定`libmylib.[so,a]`文件的路径(`-L`后面的`.`表示应该搜索当前目录)。默认情况下，如果可以找到`.so`版本，`gcc`将动态链接库。有关链接和链接路径的详细信息，请参阅 [2.9.5. 编译, 链接和C库使用](2.9.5.%20编译,%20链接和C库使用.md)。

The program can then be run:  
然后可以运行该程序：

```bash
$ ./myprog
```

If you run the dynamically linked version of `myprog`, you may encounter an error that looks like this:  
如果您运行 的动态链接版本`myprog`，您可能会遇到如下错误：

```bash
/usr/bin/ld: cannot find -lmylib
collect2: error: ld returned 1 exit status
```

This error is saying that the runtime linker cannot find `libmylib.so` at runtime. To fix this problem, set your `LD_LIBRARY_PATH` environment variable to include the path to the `libmylib.so` file. Subsequent runs of `myprog` use the path you add to `LD_LIBRARY_PATH` to find the `libmylib.so` file and load it at runtime. For example, if `libmylib.so` is in the `/home/me/mylibs/` subdirectory, run this (just once) at the bash shell prompt to set the `LD_LIBRARY_PATH` environment variable:  
此错误表明运行时链接器在运行时找不到`libmylib.so`。要解决此问题，请设置`LD_LIBRARY_PATH`环境变量以包含`libmylib.so`文件的路径。 `myprog`的后续运行使用您添加到`LD_LIBRARY_PATH`的路径来查找`libmylib.so`文件并在运行时加载它。例如，如果`libmylib.so`位于`/home/me/mylibs/`子目录中，请在 bash shell 提示符下运行此命令(仅一次)以设置`LD_LIBRARY_PATH`环境变量：

```bash
$ export LD_LIBRARY_PATH=/home/me/mylibs:$LD_LIBRARY_PATH
```