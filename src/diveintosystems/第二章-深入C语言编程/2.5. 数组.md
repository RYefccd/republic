In the [previous chapter](https://diveintosystems.org/book/C1-C_intro/arrays_strings.html#_introduction_to_arrays) we introduced statically declared one-dimensional C arrays and discussed the semantics of passing arrays to functions. In the [dynamic memory allocation section](https://diveintosystems.org/book/C2-C_depth/pointers.html#_dynamic_memory_allocation) of this chapter, we introduced dynamically allocated one dimensional arrays and discussed the semantics of passing them to functions.

In this section, we take a more in-depth look at arrays in C. We describe both statically and dynamically allocated arrays in more detail and discuss two-dimensional arrays.

在之前的[1.5.1. Introduction to Arrays](../第一章-优美的c语言/1.5.%20数组与字符串.md#1.5.1.%20Introduction%20to%20Arrays) 中，我们介绍了静态声明的一维数组，并讨论了将数组传递给函数的语义。在 [2.4. 动态内存分配](2.4.%20动态内存分配.md) 的章节中，我们介绍了动态分配的一维数组并讨论了将它们传递给函数的语义。  

在这一章节中, 我们会更深入地了解 C 中的数组，更详细地描述静态和动态分配的数组，并讨论二维数组。

### 2.5.1. 一维数组

#### 静态分配

Before jumping into new content, we briefly summarize static arrays with an example. See the [previous chapter](https://diveintosystems.org/book/C1-C_intro/arrays_strings.html#_introduction_to_arrays) for more detail on statically declared one-dimensional arrays.

在进入新内容之前，我们通过一个示例简要总结静态数组。有关静态声明的一维数组的更多详细信息，请参阅[1.5.1. Introduction to Arrays](../第一章-优美的c语言/1.5.%20数组与字符串.md#1.5.1.%20Introduction%20to%20Arrays)。

Statically declared arrays are allocated either on the stack (for local variables) or in the data region of memory (for global variables). A programmer can declare an array variable by specifying its type (the type stored at each index) and its total capacity (number of elements).

静态声明的数组分配在栈上(对于局部变量)或内存的数据段(对于全局变量, 堆上)。程序员可以通过指定数组变量的类型(存储在每个索引处的类型)及其总容量(元素数量)来声明数组变量。

When passing an array to a function, C copies the value of the base address to the parameter. That is, both the parameter and the argument refer to the same memory locations — the parameter pointer points to the argument’s array elements in memory. As a result, modifying the values stored in the array through an array parameter modifies the values stored in the argument array.

> [!NOTE] **Parameter** vs **Argument**
> **Parameter** is the variable in the declaration of the function.  
> **Argument** is the actual value of this variable that gets passed to the function. 
> [What's the difference between an argument and a parameter?](https://stackoverflow.com/questions/156767/whats-the-difference-between-an-argument-and-a-parameter)  


当将数组传递给函数时，C 会将首地址(基址)的值复制到函数参数。
也就是说，形参和实参都引用相同的内存位置 ——形参指针指向内存中实参的数组元素。因此，通过数组形参修改存储在数组中的值会修改存储在实参数组中的值。


> [!NOTE] **形参** vs **实参**
> **形参**(**Parameter**)是在函数声明中的变量。  
> **实参**(**Argument**)是传递给函数的变量的实际值。  
> [What's the difference between an argument and a parameter?](https://stackoverflow.com/questions/156767/whats-the-difference-between-an-argument-and-a-parameter)  

Here are some examples of static array declaration and use:  
以下是静态数组声明和使用的一些示例：  

```c
// declare arrays specifying their type and total capacity
float averages[30];   // array of float, 30 elements
char  name[20];       // array of char, 20 elements
int i;

// access array elements
for (i = 0; i < 10; i++) {
    averages[i] = 0.0 + i;
    name[i] = 'a' + i;
}
name[10] = '\0';    // name is being used for storing a C-style string

// prints: 3 d abcdefghij
printf("%g %c %s\n", averages[3], name[3], name);

strcpy(name, "Hello");
printf("%s\n", name);  // prints: Hello
```

#### 动态分配

In the [Dynamic Memory Allocation section](https://diveintosystems.org/book/C2-C_depth/pointers.html#_dynamic_memory_allocation) of this chapter, we introduced dynamically allocated one-dimensional arrays, including their access syntax and the syntax and semantics of passing dynamically allocated arrays to functions. Here, we present a short recap of that information with an example.

在本章的 [动态内存分配部分](2.2.%20指针变量.md)，我们介绍了动态分配的一维数组，包括它们的访问语法以及将动态分配的数组传递给函数的语法和语义。在这里，我们通过一个示例对该信息进行简短回顾。

Calling the `malloc` function dynamically allocates an array on the heap at runtime. The address of the allocated heap space can be assigned to a global or local pointer variable, which then points to the first element of the array. To dynamically allocate space, pass `malloc` the total number of bytes to allocate for the array (using the `sizeof` operator to get the size of a specific type). A single call to `malloc` allocates a contiguous chunk of heap space of the requested size. For example:

调用该`malloc`函数会在运行时在堆上动态分配一个数组。分配的堆空间的地址可以分配给全局或局部指针变量，然后该指针变量指向数组的第一个元素(首地址)。要动态分配空间，给`malloc`传递为数组分配的总字节数(使用`sizeof`运算符获取特定类型的大小)。一次`malloc`调用即可在堆上分配所请求大小的连续空间块。例如：  

```c
// declare a pointer variable to point to allocated heap space
int    *p_array;
double *d_array;

// call malloc to allocate the appropriate number of bytes for the array

p_array = malloc(sizeof(int) * 50);      // allocate 50 ints
d_array = malloc(sizeof(double) * 100);  // allocate 100 doubles

// always CHECK RETURN VALUE of functions and HANDLE ERROR return values
if ( (p_array == NULL) || (d_array == NULL) ) {
    printf("ERROR: malloc failed!\n");
    exit(1);
}

// use [] notation to access array elements
for (i = 0; i < 50; i++) {
    p_array[i] = 0;
    d_array[i] = 0.0;
}

// free heap space when done using it
free(p_array);
p_array = NULL;

free(d_array);
d_array = NULL;
```

#### 数组内存布局

Whether an array is statically declared or dynamically allocated via a single call to `malloc`, array elements represent contiguous memory locations (addresses):

无论数组是静态声明的还是通过单次调用动态分配的`malloc`，数组元素都表示连续的内存位置(地址)：

```
 array [0]:  base address
 array [1]:  next address
 array [2]:  next address
   ...            ...
 array [99]: last address
```

The location of element `i` is at an offset `i` from the base address of the array. The exact address of the ith element depends on the number of bytes of the type stored in the array. For example, consider the following array declarations:

元素的位置`i`位于距`i`数组基地址的偏移处。第 i 个元素的确切地址取决于数组中存储的类型的字节数。例如，考虑以下数组声明：  

```c
int  iarray[6];  // an array of six ints, each of which is four bytes
char carray[4];  // an array of four chars, each of which is one byte
```

The addresses of their individual array elements might look something like this:

它们各个数组元素的地址可能如下所示：

```
 addr   element
 ----   -------
 1230:  iarray[0]
 1234:  iarray[1]
 1238:  iarray[2]
 1242:  iarray[3]
 1246:  iarray[4]
 1250:  iarray[5]
     ...
 1280:  carray[0]
 1281:  carray[1]
 1282:  carray[2]
 1283:  carray[3]
```
In this example, `1230` is the base address of `iarray` and `1280` the base address of `carray`. Note that individual elements of each array are allocated to contiguous memory addresses: each element of `iarray` stores a 4-byte `int` value, so its element addresses differ by 4, and each element of `carray` stores a 1-byte `char` value, so its addresses differ by 1. There is no guarantee that the set of local variables are allocated to contiguous memory locations on the stack (hence, there could be a gap in the addresses between the end of `iarray` and the start of `carray`, as shown in this example.)

在此示例中，`1230`是`iarray`的基地址和`1280`是`carray`的基地址。请注意，每个数组的各个元素都分配到连续的内存地址： 的每个元素`iarray`存储一个 4 字节`int`值，因此其元素地址相差 4，而 的每个元素`carray`存储一个 1 字节`char`值，因此其地址相差 1。无法保证局部变量集被分配到栈上的连续内存位置(因此，`iarray`的结尾和`carray`的开头之间的地址可能存在间隙，如此例所示。)

|     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| --- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|     | Constants are often used when defining the total capacity of an array rather than using a literal numeric value. Constants are aliases for C literal values, and are used instead of literals to make the code easier to read and to allow for it to be more easily updated. See [C Constants](https://diveintosystems.org/book/C2-C_depth/advanced_switch.html#_c_constants_) to learn more about defining and using C constants.<br><br>Here is an example defining and using a constant (`N`) for the dimension of the arrays:<br><br>```c<br>#define N   20<br><br>int main(void) {<br>  int array[N];   // an array of 20 ints<br>  int *d_arr, i;<br><br>  // dynamically alloc array of 20 ints<br>  d_arr = malloc(sizeof(int)*N);<br>  if(d_arr == NULL) {<br>    exit(1);<br>  }<br><br>  for(i=0; i < N; i++) {<br>    array[i] = i;<br>    d_arr[i] = i*2;<br>  }<br>  ...<br>}<br>``` |


> [!NOTE]
> Constants are often used when defining the total capacity of an array rather than using a literal numeric value. Constants are aliases for C literal values, and are used instead of literals to make the code easier to read and to allow for it to be more easily updated. See [C Constants](https://diveintosystems.org/book/C2-C_depth/advanced_switch.html#_c_constants_) to learn more about defining and using C constants.  
> Here is an example defining and using a constant (`N`) for the dimension of the arrays:
>```c
#define N 20 
int main(void) { 
int array[N]; // an array of 20 ints 
int *d_arr, i; // dynamically alloc array of 20 ints 
d_arr = malloc(sizeof(int)*N); 
if(d_arr == NULL) {
  exit(1); 
} 
for(i=0; i < N; i++) {
  array[i] = i; 
  d_arr[i] = i*2; 
} 
... 
}
>```


> [!NOTE]
>定义数组的总容量时通常使用常量，而不是使用文字数值。常量是 C 文字值的别名，用于代替文字以使代码更易于阅读并更容易更新。请参阅[C 常量](https://diveintosystems.org/book/C2-C_depth/advanced_switch.html#_c_constants_) 以了解有关定义和使用 C 常量的更多信息(todo: link)。  
> 下面是定义和使用常量 (`N`) 作为数组维数的示例：  
>```c
#define N 20 
int main(void) { 
int array[N]; // an array of 20 ints 
int *d_arr, i; // dynamically alloc array of 20 ints 
d_arr = malloc(sizeof(int)*N); 
if(d_arr == NULL) {
  exit(1); 
} 
for(i=0; i < N; i++) {
  array[i] = i; 
  d_arr[i] = i*2; 
} 
... 
}
>```

### 2.5.2. 二维数组

C supports multidimensional arrays, but we limit our discussion of multidimensional arrays to two-dimensional (2D) arrays, since 1D and 2D arrays are the most commonly used by C programmers.  
C 支持多维数组，但我们将多维数组的讨论限制为二维 (2D) 数组，因为一维和二维数组是 C 程序员最常用的。

#### 静态分配的二维数组

To statically declare a multidimensional array variable, specify the size of each dimension. For example:  
要静态声明多维数组变量，请指定每个维度的大小。例如：

```c
int   matrix[50][100];
short little[10][10];
```

Here, `matrix` is a 2D array of `int` values with 50 rows and 100 columns, and `little` is a 2D array of `short` values with 10 rows and 10 columns.  
这里，`matrix`是一个50 行100 列`int` 类型的二维数组，`little`是一个10 行 10 列`short`类型的二维数组。

To access an individual element, indicate both the row and the column index:  
要访问单个元素，请指定行索引和列索引：

```c
int   val;
short num;

val = matrix[3][7];  // get int value in row 3, column 7 of matrix
num = little[8][4];  // get short value in row 8, column 4 of little
```

[Figure 1](https://diveintosystems.org/book/C2-C_depth/arrays.html#FigAccessingMatrix) illustrates the 2D array as a matrix of integer values, where a specific element in the 2D array is indexed by row and column index values.
[图 1](https://diveintosystems.org/book/C2-C_depth/arrays.html#FigAccessingMatrix)将 2D 数组展示为整数值矩阵，其中 2D 数组中的特定元素通过行和列索引值进行索引。  
![Accessing matrix`[2][3]` is like indexing into a grid at row 2 and column 3.](https://diveintosystems.org/book/C2-C_depth/_images/matrix.png)

Figure 1. A two-dimensional array represented as a matrix. Accessing matrix`[2][3]` is like indexing into a grid at row 2 and column 3.  
图 1. 用矩阵表示的二维数组。访问矩阵 `[2][3]` 就像在第 2 行和第 3 列处对网格进行索引。

Programs often access the elements of a 2D array by iterating with nested loops. For example, the following nested loop initializes all elements in `matrix` to 0:  
程序通常通过嵌套循环迭代来访问二维数组的元素。例如，以下嵌套循环将`matrix`所有元素初始化为 0：  

```c
int i, j;

for (i = 0; i < 50; i++) {  // for each row i
    for (j = 0; j < 100; j++) { // iterate over each column element in row i
        matrix[i][j] = 0;
    }
}
```

#### 二维数组参数

The same rules for passing one-dimensional array arguments to functions apply to passing two-dimensional array arguments: the parameter gets the value of the base address of the 2D array (`&arr[0][0]`). In other words, the parameter points to the argument’s array elements and therefore the function can change values stored in the passed array.  
将一维数组参数传递给函数的相同规则也适用于传递二维数组参数：形参(**parameter**)获取二维数组基地址的值 (`&arr[0][0]`)。换句话说，形参(**parameter**)指向实参(**argument**)的数组元素，因此函数可以更改存储在传递的数组中的值。

For multidimensional array parameters, you must indicate that the parameter is a multidimensional array, but you can leave the size of the first dimension unspecified (for good generic design). The sizes of other dimensions must be fully specified so that the compiler can generate the correct offsets into the array. Here’s a 2D example:  
对于多维数组参数，您必须指示该参数(parameter)是多维数组，但您可以不指定第一个维度的大小(为了良好的通用设计)。必须完全指定其他维度的大小，以便编译器可以生成数组中的正确偏移量。这是一个 2D 示例：  

```c
// a C constant definition: COLS is defined to be the value 100
#define COLS  (100)

/*
 * init_matrix: initializes the passed matrix elements to the
 *              product of their index values
 *   m: a 2D array (the column dimension must be 100)
 *   rows: the number of rows in the matrix
 *   return: does not return a value
 */
void init_matrix(int m[][COLS], int rows) {
    int i, j;
    for (i = 0; i < rows; i++) {
        for (j = 0; j < COLS; j++) {
            m[i][j] = i*j;
        }
    }
}

int main(void) {
    int matrix[50][COLS];
    int bigger[90][COLS];

    init_matrix(matrix, 50);
    init_matrix(bigger, 90);
    ...
```

Both the `matrix` and the `bigger` arrays can be passed as arguments to the `init_matrix` function because they have the same column dimension as the parameter definition.  
`matrix`和`bigger`数组都可以作为参数传递给 `init_matrix`函数，因为它们具有与参数定义相同的列维度。

|   |   |
|---|---|
||The column dimension must be specified in the parameter definition of a 2D array so that the compiler can calculate the offset from the base address of the 2D array to the start of a particular row of elements. The offset calculation follows from the layout of 2D arrays in memory.|

> [!NOTE] 
> 必须在 2D 数组的参数定义中指定列维度，以便编译器可以计算从 2D 数组基地址到特定行元素开头的偏移量。偏移计算根据内存中二维数组的布局进行。

#### 二维数组内存布局

Statically allocated 2D arrays are arranged in memory in **row-major order**, meaning that all of row 0’s elements come first, followed by all of row 1’s elements, and so on. For example, given the following declaration of a 2D array of integers:

**静态分配的二维数组在内存中按行优先顺序**排列，这意味着第 0 行的所有元素排在前面，然后是第 1 行的所有元素，依此类推。例如，给出以下二维整数数组的声明：

```c
int arr[3][4];  // int array with 3 rows and 4 columns
```

its layout in memory might look like [Figure 2](https://diveintosystems.org/book/C2-C_depth/arrays.html#Fig2DMem).  
[它在内存中的布局可能如图2](https://diveintosystems.org/book/C2-C_depth/arrays.html#Fig2DMem)所示。

![Declaring an array as "int arr`[3][4]`" yields three rows, each of which has four elements.  Row 0 consists of arr`[0][0]`, arr`[0][1]`, arr`[0][2]`, and arr`[0][3]`.  Row 1 consists of arr`[1][0]`, arr`[1][1]`, etc.](https://diveintosystems.org/book/C2-C_depth/_images/2Dmem.png)

Figure 2. The layout of a two-dimensional array in row-major order.  
图 2. 按行优先顺序排列的二维数组的布局。

Note that all array elements are allocated to contiguous memory addresses. That is, the base address of the 2D array is the memory address of the `[0][0]` element (`&arr[0][0]`), and subsequent elements are stored contiguously in row-major order (e.g., the entirety of row 1 is followed immediately by the entirety of row 2, and so on).
请注意，所有数组元素都分配到连续的内存地址。也就是说，二维数组的基地址是`[0][0]` 元素 (`&arr[0][0]` )的内存地址，后续元素按行优先顺序连续存储(例如，整个第 1 行紧接着整个第 2 行，以此类推)。

#### 动态分配的二维数组

Dynamically allocated 2D arrays can be allocated in two ways. For an _N_ x _M_ 2D array, either:  
动态分配的二维数组可以通过两种方式分配。对于 _N_ x _M_ 2D 阵列，可以：

1. Make a single call to `malloc`, allocating one large chunk of heap space to store all _N_ x _M_ array elements.
    
2. Make multiple calls to `malloc`, allocating an array of arrays. First, allocate a 1D array of _N_ pointers to the element type, with a 1D array of pointers for each row in the 2D array. Then, allocate _N_ 1D arrays of size _M_ to store the set of column values for each row in the 2D array. Assign the addresses of each of these _N_ arrays to the elements of the first array of _N_ pointers.
1. 每次`malloc`调用，会分配一大块堆空间来存储所有 _N_ x _M_ 数组元素。

2. 多次调用`malloc`，分配数组的数组。首先，分配一个由 _N 个_ 指向元素类型的指针组成的 1D 数组，并为 2D 数组中的每一行分配一个 1D 指针数组。然后，分配 _N 个_ 大小为 _M_ 的一维数组来存储二维数组中每行的列值集。将这 _N_ 个数组(长度为M)中的第一个元素的地址(首地址)分配给第一个长度为N的数组。

The variable declarations, allocation code, and array element access syntax differ depending on which of these two methods a programmer chooses to use.  
变量声明、分配代码和数组元素访问语法根据程序员选择使用这两种方法中的哪一种而有所不同。
#### 方法1:内存高效分配

In this method, a single call to `malloc` allocates the total number of bytes needed to store the _N_x_M_ array of values. This method has the benefit of being more memory efficient because the entire space for all _N_x_M_ elements will be allocated at once, in contiguous memory locations.

在此方法中，一次调用allocate 即可分配存储_N_ x _M_值数组`malloc`所需的字节总数。此方法的优点是内存效率更高，因为所有_N_ x _M_ 元素的整个空间将立即分配在连续的内存位置中。

The call to `malloc` returns the starting address of the allocated space (the base address of the array), which (like a 1D array) should be stored in a pointer variable. In fact, there is no semantic difference between allocating a 1D or 2D array using this method: the call to `malloc` returns the starting address of a contiguously allocated chunk of heap memory of the requested number of bytes. Because allocation of a 2D array using this method looks just like allocation for a 1D array, the programmer has to explicitly map 2D row and column indexing on top of this single chunk of heap memory space (the compiler has no implicit notion of rows or columns and thus cannot interpret double indexing syntax into this malloc’ed space).

调用`malloc`返回分配空间的起始地址(数组的基地址)，该地址(如一维数组)应存储在指针变量中。事实上，使用此方法分配一维或二维数组之间没有语义差异：调用`malloc`在内存中返回堆上连续块分配的请求字节数的起始地址。因为使用此方法分配 2D 数组看起来就像分配 1D 数组一样，所以程序员必须在该单个堆内存空间块的顶部显式映射 2D 行和列索引(编译器没有行或列的隐式概念，因此无法将双索引语法解释到这个 malloc 分配的空间中）。

Here’s an example C code snippet that dynamically allocates a 2D array using method 1:  
下面是使用方法 1 动态分配 2D 数组的 C 代码片段示例：

```c
#define N 3
#define M 4

int main(void) {
    int *two_d_array;    // the type is a pointer to an int (the element type)

    // allocate in a single malloc of N x M int-sized elements:
    two_d_array = malloc(sizeof(int) * N * M);

    if (two_d_array == NULL) {
        printf("ERROR: malloc failed!\n");
        exit(1);
    }

    ...
```

[Figure 3](https://diveintosystems.org/book/C2-C_depth/arrays.html#Fig2DOneMalloc) shows an example of allocating a 2D array using this method and illustrates what memory might look like after the call to `malloc`.
[图 3](https://diveintosystems.org/book/C2-C_depth/arrays.html#Fig2DOneMalloc)显示了使用此方法分配 2D 数组的示例，并说明了调用`malloc`.

![We can allocate an array with malloc(sizeof(int) * (3*4)) and store the base address in a stack pointer variable.  Because malloc returns a contiguous chunk of memory, we can treat the memory as a collection of rows and columns in row-major order like a statically allocated array.](https://diveintosystems.org/book/C2-C_depth/_images/2Donemalloc.png)

Figure 3. The results of allocating a 2D array with a single call to malloc.  
图 3. 通过一次调用 malloc 分配 2D 数组的结果。

Like 1D dynamically allocated arrays, the pointer variable for a 2D array is allocated on the stack. That pointer is then assigned the value returned by the call to `malloc`, which represents the base address of the contiguous chunk of _N_ x _M_ `int` storage locations in the heap memory.

与一维动态分配数组一样，二维数组的指针变量也是在堆上分配的。然后为该指针分配调用`malloc`返回的值，该值表示堆内存中 _N_  x _M_ 个 `int`类型的连续块的基地址。

Because this method uses a single chunk of malloc’ed space for the 2D array, the memory allocation is as efficient as possible (it only requires one call to `malloc` for the entire 2D array). It’s the more efficient way to access memory due to all elements being located close together in contiguous memory, with each access requiring only a single level of indirection from the pointer variable.

由于此方法为 2D 数组使用单个 malloc 空间，因此内存分配尽可能高效(`malloc`整个 2D 数组只需要一次调用)。这是访问内存的更有效方法，因为所有元素都位于连续内存中，每次访问仅需要来自指针变量的单级间接访问。

However, the C compiler does not know the difference between a 2D or 1D array allocation using this method. As a result, the double indexing syntax (`[i][j]`) of statically declared 2D arrays _cannot_ be used when allocating a 2D array using this method. Instead, the programmer must explicitly compute the offset into the contiguous chunk of heap memory using a function of row and column index values (`[i*M + j]`, where `M` is the column dimension).

但是，C 编译器不知道使用此方法进行 2D 或 1D 数组分配之间的区别。因此，使用此方法分配 2D 数组时，_不能_ 使用静态声明的 2D 数组的双索引语法(`[i][j]`) 。相反，程序员必须使用行和列索引值的函数(`[i*M + j]`  `M`其中是列维度)显式计算到堆内存的连续块中的偏移量。

Here’s an example of how a programmer would structure code to initialize all the elements of a 2D array:  
下面是程序员如何构造代码来初始化 2D 数组的所有元素的示例：

```c
// access using [] notation:
//   cannot use [i][j] syntax because the compiler has no idea where the
//   next row starts within this chunk of heap space, so the programmer
//   must explicitly add a function of row and column index values
//   (i*M+j) to map their 2D view of the space into the 1D chunk of memory
for (i = 0; i < N; i++) {
    for (j = 0; j < M; j++) {
        two_d_array[i*M + j] = 0;
    }
}
```

##### 单个malloc和函数参数

The base address of an array of `int` types allocated via a single `malloc` is a pointer to an `int`, so it can be passed to a function with an (`int *`) parameter. Additionally, the function must be passed row and column dimensions so that it can correctly compute offsets into the 2D array. For example:  
通过单个`malloc`分配的`int`类型数组的基址是一个指向`int`的指针，因此可以将其传递给带有(`int *`)参数的函数。此外，该函数必须传递行和列维度，以便它可以正确计算二维数组的偏移量。例如：

```c
/*
 * initialize all elements in a 2D array to 0
 *  arr: the array
 *  rows: number of rows
 *  cols: number of columns
 */
void init2D(int *arr, int rows, int cols) {
    int i, j;
    for (i = 0; i < rows; i++) {
        for (j = 0; j < cols; j++) {
            arr[i*cols + j] = 0;
        }
    }
}

int main(void) {
    int *array;
    array = malloc(sizeof(int) * N * M);
    if (array != NULL) {
        init2D(array, N, M);
    }
    ...
```

#### 方法 2:程序员友好的方法

The second method for dynamically allocating a 2D array stores the array as an array of _N_ 1D arrays (one 1D array per row). It requires _N+1_ calls to `malloc`: one `malloc` for the array of row arrays, and one `malloc` for each of the _N_ row’s column arrays. As a result, the element locations _within a row_ are contiguous, but elements are not contiguous across rows of the 2D array. Allocation and element access are not as efficient as in method 1, and the type definitions for variables can be a bit more confusing. However, using this method, a programmer can use double indexing syntax to access individual elements of the 2D array (the first index is an index into the array of rows, the second index is an index into the array of column elements within that row).  

动态分配 2D 数组的第二种方法将数组存储为 _N 个_ 1D 数组的数组(每行一个 1D 数组)。它需要 _N+1 次_ 调用 `malloc`：一次`malloc`用于行数组的数组，一次`malloc`用于 _N_ 行列数组中的每一个。因此，_行内的_ 元素位置是连续的，但元素在 2D 数组的行之间不连续。分配和元素访问不如方法 1 高效，并且变量的类型定义可能有点混乱。但是，使用此方法，程序员可以使用双索引语法来访问 2D 数组的各个元素(第一个索引是行数组的索引，第二个索引是该行内列元素数组的索引) 。

Here is an example of allocating a 2D array using method 2 (with the error detection and handling code removed for readability):  
以下是使用方法 2 分配 2D 数组的示例(为了便于阅读，删除了错误检测和处理代码)：  

```c
// the 2D array variable is declared to be `int **` (a pointer to an int *)
// a dynamically allocated array of dynamically allocated int arrays
// (a pointer to pointers to ints)
int **two_d_array;
int i;

// allocate an array of N pointers to ints
// malloc returns the address of this array (a pointer to (int *)'s)
two_d_array = malloc(sizeof(int *) * N);

// for each row, malloc space for its column elements and add it to
// the array of arrays
for (i = 0; i < N; i++) {
// malloc space for row i's M column elements
    two_d_array[i] = malloc(sizeof(int) * M);
}
```

In this example, note the types of the variables and the sizes passed to the calls to `malloc`. To refer to the dynamically allocated 2D array, the programmer declares a variable (`two_d_array`) of type `int **` that will store the address of a dynamically allocated array of `int *` element values. Each element in `two_d_array` stores the address of a dynamically allocated array of `int` values (the type of `two_d_array[i]` is `int *`).

在此示例中，请注意传递给`malloc`的调用的变量类型和大小。为了引用动态分配的二维数组，程序员声明一个`int **`类型的变量(`two_d_array`)，该变量将存储动态分配的元素值`int *`数组的地址。`two_d_array`中的每个元素存储动态分配 `int`类型的数组的地址(`two_d_array[i]`的类型是`int *`)。

[Figure 4](https://diveintosystems.org/book/C2-C_depth/arrays.html#Fig2DNMallocs) shows what memory might look like after the above example’s _N+1_ calls to `malloc`.  
[图 4显示了上述示例对 进行](https://diveintosystems.org/book/C2-C_depth/arrays.html#Fig2DNMallocs) _N+1 次_ 调用`malloc`后内存的情况。

![two_d_array is a stack variable that points to a dynamically allocated array of pointers.  Each of those pointers points to a 1D array of integers.](https://diveintosystems.org/book/C2-C_depth/_images/2Dnmallocs.png)

Figure 4. The arrangement of memory after allocating a 2D array with N+1 malloc calls.  
图 4. 使用 N+1 malloc 调用分配 2D 数组后的内存排列。  

Note that when using this method, only the elements allocated as part of a single call to `malloc` are contiguous in memory. That is, elements within each row are contiguous, but elements from different rows (even neighboring rows) are not.

请注意，使用此方法时，只有作为单个调用的一部分分配的元素`malloc`在内存中是连续的。也就是说，每行内的元素是连续的，但不同行(甚至相邻行)的元素不是连续的。

Once allocated, individual elements of the 2D array can be accessed using double-indexing notation. The first index specifies an element in the outer array of `int *` pointers (which row), and the second index specifies an element in the inner `int` array (which column within the row).  
分配后，可以使用双索引表示法访问二维数组的各个元素。第一个索引指定外部指针数组中的元素`int *`（哪一行），第二个索引指定内部数组中的元素`int`(行中的哪一列)。

```c
int i, j;

for (i = 0; i < N; i++) {
    for (j = 0; j < M; j++) {
        two_d_array[i][j] = 0;
    }
}
```

To understand how double indexing is evaluated, consider the type and value of the following parts of the expression:  
要了解双索引的计算方式，请考虑表达式以下部分的类型和值：  

       two_d_array: an array of int pointers, it stores the base address of an
                 array of (int *) values. Its type is int** (a pointer to int *).

    two_d_array[i]: the ith index into the array of arrays, it stores an (int *)
                 value that represents the base address of an array of (int)
                 values.  Its type is int*.

	 two_d_array[i][j]: the jth element pointed to by the ith element of the array of
	                 arrays, it stores an int value (the value in row i, column j
	                 of the 2D array).  Its type is int.

##### 数组的数组和函数参数

The array argument’s type is `int **` (a pointer to a pointer to an `int`), and the function parameter matches its argument’s type. Additionally, row and column sizes should be passed to the function. Because this is a different type from method 1, both array types cannot use a common function (they are not the same C type).

数组实参的类型是`int **`（指向 `int` 类型指针的指针)，并且函数形参与其参数(数组实参)的类型匹配。此外，行和列的大小应传递给函数。因为这是与方法 1 不同的类型，所以两种数组类型不能使用公共函数(它们不是相同的 C 类型)。

Here’s an example function that takes a method 2 (array of arrays) 2D array as a parameter:  
下面是一个示例函数，它采用方法 2(数组的数组)二维数组作为参数：  

```c
/*
 * initialize a 2D array
 * arr: the array
 * rows: number of rows
 * cols: number of columns
 */
void init2D_Method2(int **arr, int rows, int cols) {
    int i,j;

    for (i = 0; i < rows; i++) {
        for (j = 0; j < cols; j++) {
            arr[i][j] = 0;
        }
    }
}

/*
 * main: example of calling init2D_Method2
 */
int main(void) {
    int **two_d_array;

    // some code to allocate the row array and multiple col arrays
    // ...

    init2D_Method2(two_d_array, N, M);
    ...
```

Here, the function implementation can use double-indexing syntax. Unlike statically declared 2D arrays, both the row and column dimensions need to be passed as parameters: the `rows` parameter specifies the bounds on the outermost array (the array of row arrays), and the `cols` parameter specifies the bounds on the inner arrays (the array column values for each row).  
这里，函数实现可以使用双索引语法。与静态声明的二维数组不同，行和列的维度都需要作为参数传递：参数`rows`指定最外层数组(行数组的数组)的边界，参数`cols`指定内部数组(数组列中每一行的值)。