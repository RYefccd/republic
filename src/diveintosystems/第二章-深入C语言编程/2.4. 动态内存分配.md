In addition to pass-by-pointer parameters, programs commonly use pointer variables to dynamically allocate memory. Such **dynamic memory allocation** allows a C program to request more memory as it’s running, and a pointer variable stores the address of the dynamically allocated space. Programs often allocate memory dynamically to tailor the size of an array for a particular run.

Dynamic memory allocation grants flexibility to programs that:

- do not know the size of arrays or other data structures until runtime (e.g. the size depends on user input)
    
- need to allow for a variety of input sizes (not just up to some fixed capacity)
    
- want to allocate exactly the size of data structures needed for a particular execution (don’t waste capacity)
    
- grow or shrink the sizes of memory allocated as the program runs, reallocating more space when needed and freeing up space when it’s no longer required.

除了通过指针传递参数之外, 程序通常使用指针变量来动态分配内存. 这种**动态内存分配**可以让c语言程序在运行时请求更多内存, 指针变量存储了动态分配内存空间的地址. 程序通常动态分配内存以调整特定运行的数组大小.

动态内存分配为程序提供了灵活性:

- 在运行时之前不需要知道数组或者其他数据结构的大小.(比如依赖用户输入的大小)
- 需要允许各种输入大小(非固定大小)
- 可以准确分配在运行时所需要的数据结构大小(避免浪费存储容量)
- 在程序运行时增长或者缩小内存分配的大小, 可以在需要时分配更多的空间, 在不需要时去释放空间.
### 2.4.1. Heap Memory

Every byte of memory in a program’s memory space has an associated address. Everything the program needs to run is in its memory space, and different types of entities reside in different parts of a program’s memory space. For example, the _code_ region contains the program’s instructions, global variables reside in the _data_ region, local variables and parameters occupy the _stack_, and dynamically allocated memory comes from the _heap_. Because the stack and the heap grow at runtime (as functions are called and return and as dynamic memory is allocated and freed), they are typically far apart in a program’s address space to leave a large amount of space for each to grow into as the program runs.

程序内存空间的每一个字节都有一个与之对应的地址. 程序运行所需的一切都在其内存空间中，不同类型的实体驻留在程序内存空间的不同部分. 举个例子, _code_(代码段)包换程序的指令, 全局变量存储在 _data_ (数据段)中, 局部变量和参数占据 _stack_ (栈)的空间, 动态内存来自 _heap_ (堆)中. 因为栈和堆在运行时增长(随着函数的调用和返回以及动态内存的分配和释放), 它们通常在程序的地址空间内相距很远, 从而为程序运行留下大量的可用空间.

Dynamically allocated memory occupies the [**heap** memory](https://diveintosystems.org/book/C2-C_depth/scope_memory.html#_memoryparts) region of a program’s address space. When a program dynamically requests memory at runtime, the heap provides a chunk of memory whose address must be assigned to a pointer variable.

动态分配内存来自于程序地址空间的堆内存. 当程序在运行时动态的申请内存, 堆提供了一块内存，其地址必须分配给指针变量。

[Figure 1](https://diveintosystems.org/book/C2-C_depth/dynamic_memory.html#FigProgramMemory) illustrates the parts of a running program’s memory with an example of a pointer variable (`ptr`) on the stack that stores the address of dynamically allocated heap memory (it points to heap memory).

[Figure 1](https://diveintosystems.org/book/C2-C_depth/dynamic_memory.html#FigProgramMemory) 以栈上的指针变量(`ptr`)为例说明了正在运行的程序的内存部分, 该变量存储动态分配的堆内存的地址(它指向堆内存).

![The parts of program memory showing a stack variable pointing to dynamically allocated heap memory.](https://diveintosystems.org/book/C2-C_depth/_images/program_memory.png)

Figure 1. A pointer on the stack points to a block of memory that was allocated from the heap.
Figure 1. 栈上的指针指向从堆中分配的内存块.

It’s important to remember that heap memory is anonymous memory, where "anonymous" means that addresses in the heap are not bound to variable names. Declaring a named program variable allocates it on the stack or in the data part of program memory. A local or global pointer variable can store the address of an anonymous heap memory location (e.g. a local pointer variable on the stack can point to heap memory), and dereferencing such a pointer enables a program to store data in the heap.

值得注意的重点是堆空间是匿名内存, 其中"匿名"意味着堆中的地址没有与之绑定的变量名. 声明一个命名的变量会被分配在栈上(局部变量)或者出现在程序内存布局中的数据段(全局变量). 一个局部指针变量或全局指针变量可以存储匿名堆内存位置的地址(例如, 栈上的局部指针变量可以指向堆内存), 并且解引用此指针可以对堆中的数据进行操作.

### 2.4.2. malloc and free

**malloc** and **free** are functions in the standard C library (`stdlib`) that a program can call to allocate and deallocate memory in the **heap**. Heap memory must be explicitly allocated (malloc’ed) and deallocated (freed) by a C program.

**malloc** 和 **free** 都是C标准库(`stdlib`)中的函数, 程序可以调用它们用来分配和释放在堆中的内存. 堆内存必须由C程序显式分配(malloc)和释放(free).

To allocate heap memory, call `malloc`, passing in the total number of bytes of contiguous heap memory to allocate. Use the **`sizeof` operator** to compute the number of bytes to request. For example, to allocate space on the heap to store a single integer, a program could call:

为了分配堆中的内存, 调用 `malloc`, 传入要分配堆中的连续内存的字节总数. 使用 **`sizeof` 操作符** 计算要请求的字节数. 举个例子, 为了在堆上分配空间去存储一个整型, 程序可以进行如下调用:

```c
// Determine the size of an integer and allocate that much heap space.
malloc(sizeof(int));
```

The `malloc` function returns the base address of the allocated heap memory to the caller (or `NULL` if an error occurs). Here’s a full example program with a call to `malloc` to allocate heap space to store a single `int` value:

`malloc` 函数向调用函数返回分配的堆中内存的基地址(首地址, 或者在出错的情况下返回 `NULL`). 这是一个完整的示例程序，其中调用 `malloc` 去分配堆内存空间存储一个 `int` 值:

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
    int *p;

    p = malloc(sizeof(int));  // allocate heap memory for storing an int

    if (p != NULL) {
        *p = 6;   // the heap memory p points to gets the value 6
    }
}
```

The `malloc` function returns a `void *` type, which represents a generic pointer to a non-specified type (or to any type). When a program calls `malloc` and assigns the result to a pointer variable, the program associates the allocated memory with the type of the pointer variable.

`malloc` 函数返回 `void *` 类型(万能指针), 这表示指向非指定类型(或任何类型)的通用指针. 当程序调用 `malloc` 并且将结果分配给指针变量时, 程序会将分配的内存与指针变量类型相关联.

Sometimes you may see calls to `malloc` that explicitly recast its return type from `void *` to match the type of the pointer variable. For example:

有时候你可以看到调用 `malloc` 并将返回的类型显式地从 `void *` 转化为对应的指针类型. 例如:

```c
p = (int *) malloc(sizeof(int));
```

The `(int *)` before `malloc` tells the compiler that the `void *` type returned by `malloc` will be used as an `int *` in this call (it recasts the return type of `malloc` to an `int *`). We discuss [type recasting and the `void *` type](https://diveintosystems.org/book/C2-C_depth/advanced_voidstar.html#_c_voidstar_recasting_) in more detail later in this chapter.

在 `malloc` 前的 `(int *)` 告诉编译器把 `malloc` 返回的 `void *` 当作  `int *` 类型(它将 `malloc` 返回的类型转换为 `int *`). 我们将会 [type recasting and the `void *` type](https://diveintosystems.org/book/C2-C_depth/advanced_voidstar.html#_c_voidstar_recasting_)章节进行更详细的讨论.

A call to `malloc` fails if there is not enough free heap memory to satisfy the requested number of bytes to allocate. Usually, `malloc` failing indicates an error in the program such as passing `malloc` a very large request, passing a negative number of bytes, or calling `malloc` in an infinite loop and running out of heap memory. Because any call to `malloc` can fail, you should _always test its return value for NULL_ (indicating `malloc` failed) before dereferencing the pointer value. Dereferencing a NULL pointer will cause your program to crash! For example:

如果没有足够的堆内存满足请求分配的字节数, `malloc` 调用会失败. 通常来说, `malloc` 失败表示程序出现错误比如向 `malloc` 传递非常大的请求,传递负数字节, 或者在无限循环中调用 `malloc` 并耗尽堆内存. 因为调用 `malloc` 可能失败, 在指针值进行解引用前, 你应该总是对它的返回值进行空值测试(表明 `malloc` 失败). 对空指针进行解引用会导致程序崩溃!举个例子:

```c
int *p;

p = malloc(sizeof(int));
if (p == NULL) {
    printf("Bad malloc error\n");
    exit(1);   // exit the program and indicate error
}
*p = 6;
```

When a program no longer needs the heap memory it dynamically allocated with `malloc`, it should explicitly deallocate the memory by calling the `free` function. It’s also a good idea to set the pointer’s value to `NULL` after calling `free`, so that if an error in the program causes it to be accidentally dereferenced after the call to `free`, the program will crash rather than modify parts of heap memory that have been reallocated by subsequent calls to `malloc`. Such unintended memory references can result in undefined program behavior that is often very difficult to debug, whereas a null pointer dereference will fail immediately, making it a relatively easy bug to find and to fix.

当程序不再需要它在堆上通过 `malloc` 动态分配的内存时, 它可以通过调用 `free` 函数显式释放内存. 在调用 `free` 之后把指针的值设置为`NULL`也是一个好主意, 这样如果程序中的错误导致在调用`free`之后意外取消引用, 程序将崩溃而不是释放堆内存后供后续的调用 `malloc` 来重新分配(**todo:考虑这句是否重新翻译**). 这种意外的内存引用可能会导致未定义的程序行为, 这通常很难调试, 而空指针解引用将立即失败, 使其成为相对容易查找和修复的错误.

```c
free(p);
p = NULL;
```

### 2.4.3. Dynamically Allocated Arrays and Strings

C programmers often dynamically allocate memory to store arrays. A successful call to `malloc` allocates one contiguous chunk of heap memory of the requested size. It returns the address of the start of this chunk of memory to the caller, making the returned address value suitable for the base address of a dynamically allocated array in heap memory.

C程序员经常使用动态分配的内存来存储数组. 成功调用 `malloc` 会分配请求大小的一块连续的的堆内存. 它将这块内存的起始地址返回给调用者, 使返回的地址值适合堆内存中动态分配数组的基地址。

To dynamically allocate space for an array of elements, pass `malloc` the total number of bytes in the desired array. That is, the program should request from `malloc` the total number of bytes in each array element times the number of elements in the array. Pass `malloc` an expression for the total number of bytes in the form of `sizeof(<type>) * <number of elements>`. For example:

要为元素数组动态分配空间, 给 `malloc` 传递所需数组中的总字节数. 
也就是说, 程序应该从 `malloc` 请求每个数组元素中的字节总数乘以数组中的元素数. 用  `sizeof(<type>) * <number of elements>` 这种表达式给 `malloc` 传递总字节数参数. 举个例子:

```c
int *arr;
char *c_arr;

// allocate an array of 20 ints on the heap:
arr = malloc(sizeof(int) * 20);

// allocate an array of 10 chars on the heap:
c_arr = malloc(sizeof(char) * 10);
```

After the calls to `malloc` in this example, the `int` pointer variable `arr` stores the base address of an array of 20 contiguous integer storage locations in heap memory, and the `c_arr` char pointer variable stores the base address of an array of 10 contiguous char storage locations in heap memory. [Figure 2](https://diveintosystems.org/book/C2-C_depth/dynamic_memory.html#FigHeapArray) depicts what this might look like.

在本例中调用`malloc`之后, `int`指针变量`arr`存储堆内存中 20 个连续整数存储位置的数组的基地址, 而`c_arr`指针变量存储堆内存中 10 个连续字符存储位置的数组。[图 2](https://diveintosystems.org/book/C2-C_depth/dynamic_memory.html#FigHeapArray) 描绘了这可能的样子。

![Main’s stack holds two pointer variables.  The first, arr, contains the address of a block of memory on the heap with enough space for 20 integers.  The second, c_arr, contains the address of a different block of memory on the heap with enough space for 10 characters.](https://diveintosystems.org/book/C2-C_depth/_images/heaparray.png)

Figure 2. A 20-element integer array and 10-element character array allocated on the heap.
图 2. 20元素的整型数组和10元素的字符数组在堆上分配的空间

Note that while `malloc` returns a pointer to dynamically allocated space in heap memory, C programs store the pointer to heap locations on the stack. The pointer variables contain _only the base address_ (the starting address) of the array storage space in the heap. Just like statically declared arrays, the memory locations for dynamically allocated arrays are in contiguous memory locations. While a single call to `malloc` results in a chunk of memory of the requested number of bytes being allocated, multiple calls to `malloc` _will not_ result in heap addresses that are contiguous (on most systems). In the example above, the `char` array elements and the `int` array elements may be at addresses that are far apart in the heap.

请注意, 虽然`malloc`返回指向堆内存中动态分配空间的指针, 但 C 程序将该指向堆的指针存储在栈上. 指针变量仅包含堆中数组存储空间的基地址(起始地址) .就像静态声明的数组一样,动态分配的数组的内存位置位于连续的内存位置. 虽然对`malloc`的单次调用会导致分配所请求字节数的一块内存, 但对`malloc`的多次调用 _不会_ 导致连续的堆地址(在大多数系统上). 在上面的示例中, `char`数组元素和`int`数组元素可能位于堆中相距较远的地址.

After dynamically allocating heap space for an array, a program can access the array through the pointer variable. Because the pointer variable’s value represents the base address of the array in the heap, we can use the same syntax to access elements in dynamically allocated arrays as we use to access elements in [statically declared arrays](https://diveintosystems.org/book/C1-C_intro/arrays_strings.html#_arrays_and_strings). Here’s an example:

```c
int i;
int s_array[20];
int *d_array;

d_array = malloc(sizeof(int) * 20);
if (d_array == NULL) {
    printf("Error: malloc failed\n");
    exit(1);
}

for (i=0; i < 20; i++) {
    s_array[i] = i;
    d_array[i] = i;
}

printf("%d %d \n", s_array[3], d_array[3]);  // prints 3 3
```

It may not be obvious why the same syntax can be used for accessing elements in dynamically allocated arrays as is used in accessing elements in statically declared arrays. However, even though their types are different, the values of `s_array` and `d_array` both evaluate to the base address of the array in memory.

Table 1. Comparison of Statically Allocated s_array and Dynamically Allocated d_array

|Expression|Value|Type|
|---|---|---|
|s_array|base address of array in memory|(static) array of int|
|d_array|base address of array in memory|int pointer (int *)|

Because the names of both variables evaluate to the base address of the array in memory (the address of the first element memory), the semantics of the `[i]` syntax following the name of the variable remain the same for both: `[i]` _dereferences the int storage location at offset i from the base address of the array in memory_ — it’s accessing the _i_th element.

For most purposes, we recommend using the `[i]` syntax to access the elements of a dynamically allocated array. However, programs can also use the pointer dereferencing syntax (the `*` operator) to access array elements. For example, placing a `*` in front of a pointer that refers to a dynamically allocated array will dereference the pointer to access element 0 of the array:

```c
/* these two statements are identical: both put 8 in index 0 */
d_array[0] = 8; // put 8 in index 0 of the d_array
*d_array = 8;   // in the location pointed to by d_array store 8
```

The [Arrays section](https://diveintosystems.org/book/C2-C_depth/arrays.html#_arrays_in_c) describes arrays in more detail, and the [Pointer Arithmetic section](https://diveintosystems.org/book/C2-C_depth/advanced_pointer_arithmetic.html#_c_ptr_arith_) discusses accessing array elements through pointer variables.

When a program is finished using a dynamically allocated array, it should call `free` to deallocate the heap space. As mentioned earlier, we recommend setting the pointer to `NULL` after freeing it:

```c
free(arr);
arr = NULL;

free(c_arr);
c_arr = NULL;

free(d_array);
d_array = NULL;
```


> [!NOTE] Heap Memory Management, malloc and free
The C standard library implements `malloc` and `free`, which are the programming interface to its heap memory manager. When called, `malloc` needs to find a contiguous chunk of unallocated heap memory space that can satisfy the size of the request. The heap memory manager maintains a **free list** of unallocated **extents** of heap memory, where each extent specifies the start address and size of a contiguous unallocated chunk of heap space.
>
Initially, all of heap memory is empty, meaning that the free list has a single extent consisting of the entire heap region. After a program has made some calls to `malloc` and `free`, heap memory can become **fragmented**, meaning that there are chunks of free heap space interspersed with chunks of allocated heap space. The heap memory manager typically keeps lists of different ranges of sizes of heap space to enable fast searching for a free extent of a particular size. In addition, it implements one or more policies for choosing among multiple free extents that could be used to satisfy a request.
>
The `free` function may seem odd in that it only expects to receive the address of the heap space to free without needing the size of the heap space to free at that address. That’s because `malloc` not only allocates the requested memory bytes, but it also allocates a few additional bytes right before the allocated chunk to store a header structure. The header stores metadata about the allocated chunk of heap space, such as the size. As a result, a call to `free` only needs to pass the address of heap memory to free. The implementation of `free` can get the size of the memory to free from the header information that is in memory right before the address passed to `free`.
>
For more information about heap memory management, see an OS textbook (for example, Chapter 17 ``Free Space Management'', in [OS in Three Easy Pieces](http://pages.cs.wisc.edu/~remzi/OSTEP/#book-chapters) covers these details).

### 2.4.4. Pointers to Heap Memory and Functions

When passing a dynamically allocated array to a function, the pointer variable argument’s _value_ is passed to the function (i.e., the base address of the array in the heap is passed to the function). Thus, when passing either statically declared or dynamically allocated arrays to functions, the parameter gets exactly the same value — the base address of the array in memory. As a result, the same function can be used for statically and dynamically allocated arrays of the same type, and identical syntax can be used inside the function for accessing array elements. The parameter declarations `int *arr` and `int arr[]` are equivalent. However, by convention, the pointer syntax tends to be used for functions that may be called with dynamically allocated arrays:

```c
int main(void) {
    int *arr1;

    arr1 = malloc(sizeof(int) * 10);
    if (arr1 == NULL) {
        printf("malloc error\n");
        exit(1);
    }

    /* pass the value of arr1 (base address of array in heap) */
    init_array(arr1, 10);
    ...
}

void init_array(int *arr, int size) {
    int i;
    for (i = 0; i < size; i++) {
        arr[i] = i;
    }
}
```

At the point just before returning from the `init_array` function, the contents of memory will look like [Figure 3](https://diveintosystems.org/book/C2-C_depth/dynamic_memory.html#FigHeapArrayParam). Note that when `main` passes `arr1` to `init_array`, it’s passing only the base address of the array. The array’s large block of contiguous memory remains on the heap, and the function can access it by dereferencing the `arr` pointer parameter. It also passes the size of the array so that `init_array` knows how many elements to access.

![Main’s arr1 and init_array’s arr variable both store the same base address of a block of heap memory.](https://diveintosystems.org/book/C2-C_depth/_images/heaparrayparam.png)

Figure 3. The contents of memory prior to returning from init_array. Both main’s arr1 and init_array’s arr variable point to the same block of heap memory.