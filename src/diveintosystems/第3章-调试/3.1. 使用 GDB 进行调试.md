## 3.1. 使用 GDB 进行调试

[GDB](https://www.gnu.org/software/gdb/) can help programmers find and fix bugs in their programs. GDB works with programs compiled in a variety of languages, but we focus on C here. A debugger is a program that controls the execution of another program (the program being debugged) — it allows programmers to see what their programs are doing as they run. Using a debugger can help programmers discover bugs and determine the causes of the bugs they find. Here are some useful actions that GDB can perform:

- Start a program and step through it line by line
    
- Pause the execution of a program when it reaches certain points in its code
    
- Pause the execution of a program on user-specified conditions
    
- Show the values of variables at the point in execution that a program is paused
    
- Continue a program’s execution after a pause
    
- Examine the program’s execution state at the point when it crashes
    
- Examine the contents of any stack frame on the call stack

  
[GDB](https://www.gnu.org/software/gdb/) 可以帮助程序员查找并修复程序中的错误。 GDB 可以处理用多种语言编译的程序，但我们这里主要关注 C。调试器是一个控制另一个程序(正在被调试的程序)执行的程序——它允许程序员看到他们的程序在运行时正在做什么。使用调试器可以帮助程序员发现错误并确定他们发现的错误的原因。以下是 GDB 可以执行的一些有用操作：

- 启动一个程序并逐行执行它
- 当程序到达代码中的某些点时暂停程序的执行
- 根据用户指定的条件暂停程序的执行
- 显示程序暂停执行点处的变量值
- 暂停后继续执行程序
- 检查程序崩溃时的执行状态
- 检查调用堆栈上任何堆栈帧的内容

GDB users typically set **breakpoints** in their programs. A breakpoint specifies a point in the program where GDB will pause the program’s execution. When the executing program hits a breakpoint, GDB pauses its execution and allows the user to enter GDB commands to examine program variables and stack contents, step through the execution of the program one line at a time, add new breakpoints, and continue the program’s execution until it hits the next breakpoint.  
GDB 用户通常会在其程序中设置**断点**(**breakpoints**)。断点指定程序中 GDB 将暂停程序执行的点。当正在执行的程序遇到断点时，GDB 暂停执行，并允许用户输入 GDB 命令来检查程序变量和堆栈内容，一次一行地执行程序，添加新断点，然后继续程序的执行直到遇到下一个断点。

Many Unix systems also provide the [Data Display Debugger (DDD)](https://www.gnu.org/software/ddd/), an easy-to-use GUI wrapper around a command-line debugger program (GDB, for example). The DDD program accepts the same parameters and commands as GDB, but it provides a GUI interface with debugging menu options as well as the command line interface to GDB.  
许多 Unix 系统还提供[数据显示调试器 (Data Display Debugger, DDD)](https://www.gnu.org/software/ddd/)，这是一个围绕命令行调试程序（GDB，用于例子）。 DDD 程序接受与 GDB 相同的参数和命令，但它提供了带有调试菜单选项的 GUI 界面以及 GDB 的命令行界面。

After discussing a few preliminaries about how to [get started with GDB](https://diveintosystems.org/book/C3-C_debug/gdb.html#_getting_started_with_gdb), we present two example GDB debugging sessions that introduce commonly used GDB commands in the context of finding different types of bugs. The first session ([GDB on badprog.c](https://diveintosystems.org/book/C3-C_debug/gdb.html#_example_gdb_sessions)), shows how to use GDB commands to find logic bugs in a C program. The second session ([GDB on segfaulter.c](https://diveintosystems.org/book/C3-C_debug/gdb.html#_segfaulter_)) shows an example of using GDB commands to examine the program execution state at the point when a program crashes in order to discover the cause of the crash.  
在讨论了一些关于如何[开始使用 GDB](https://diveintosystems.org/book/C3-C_debug/gdb.html#_getting_started_with_gdb) 的预备知识后，我们提供了两个示例 GDB 调试会话，介绍了常用的 GDB 命令查找不同类型错误的上下文。第一个会话（[GDB on badprog.c](https://diveintosystems.org/book/C3-C_debug/gdb.html#_example_gdb_sessions)）展示了如何使用 GDB 命令查找 C 程序中的逻辑错误。第二个会话（[GDB on segfaulter.c](https://diveintosystems.org/book/C3-C_debug/gdb.html#_segfaulter_)）展示了使用 GDB 命令检查此时的程序执行状态的示例程序崩溃时要找出崩溃的原因。

In the [common GDB commands](https://diveintosystems.org/book/C3-C_debug/gdb_commands.html#_common_gdb_commands) section, we describe commonly used GDB commands in more detail, showing more examples of some commands. In later sections, we discuss some advanced GDB features.  
在[常用 GDB 命令](https://diveintosystems.org/book/C3-C_debug/gdb_commands.html#_common_gdb_commands) 部分中，我们更详细地描述了常用的 GDB 命令，并显示了一些命令的更多示例。在后面的部分中，我们将讨论一些高级 GDB 功能。

### 3.1.1. GDB 入门

When debugging a program, it helps to compile it with the `-g` option, which adds extra debugging information to the binary executable file. This extra information helps the debugger find program variables and functions in the binary executable and enables it to map machine code instructions to lines of C source code (the form of the program that the C programmer understands). Also, when compiling for debugging, avoid compiler optimizations (for example, do not build with `-O2`). Compiler-optimized code is often very difficult to debug because sequences of optimized machine code often do not clearly map back to C source code. Although we cover the use of the `-g` flag in the following sections, some users may get better results with the `-g3` flag, which can reveal extra debugging information.  
调试程序时，使用`-g`选项对其进行编译很有帮助，该选项会向二进制可执行文件添加额外的调试信息。这些额外信息有助于调试器在二进制可执行文件中查找程序变量和函数，并使其能够将机器代码指令映射到 C 源代码行(C 程序员理解的程序形式)。此外，在编译调试时，请避免编译器优化(例如，不要使用`-O2`进行构建)。编译器优化的代码通常很难调试，因为优化的机器代码序列通常不能清楚地映射回 C 源代码。尽管我们在以下部分中介绍了`-g`标志的使用，但某些用户可能会使用`-g3`标志获得更好的结果，该标志可以显示额外的调试信息。

Here is an example `gcc` command that will build a suitable executable for debugging with GDB:

$ gcc -g myprog.c

To start GDB, invoke it on the executable file. For example:

$ gdb a.out
(gdb)          # the gdb command prompt

When GDB starts, it prints the `(gdb)` prompt, which allows the user to enter GDB commands (such as setting breakpoints) before it starts running the `a.out` program.

Similarly, to invoke DDD on the executable file:

$ ddd a.out

Sometimes, when a program terminates with an error, the operating system dumps a core file containing information about the state of the program when it crashed. The contents of this core file can be examined in GDB by running GDB with the core file and the executable that generated it:

$ gdb core a.out
(gdb) where       # the where command shows point of crash

下面是一个示例“gcc”命令，它将构建一个合适的可执行文件以使用 GDB 进行调试： 

```bash
$ gcc -g myprog.c
```

要启动 GDB，请在可执行文件上调用它。例如：

```bash
$ gdb a.out
(gdb)          # the gdb command prompt
```

当 GDB 启动时，它会打印“(gdb)”提示符，该提示符允许用户在开始运行“a.out”程序之前输入 GDB 命令（例如设置断点）。

类似地，要对可执行文件调用 DDD：  

```bash
$ ddd a.out
```

有时，当程序因错误而终止时，操作系统会转储一个核心文件，其中包含有关程序崩溃时的状态信息。通过使用核心文件和生成它的可执行文件运行 GDB，可以在 GDB 中检查此核心文件的内容：  

```bash
$ gdb core a.out
(gdb) where       # the where command shows point of crash
```

### 3.1.2. GDB 会话示例

We demonstrate common features of GDB through two example sessions of using GDB to debug programs. The first is an example of using GDB to find and fix two bugs in a program, and the second is an example of using GDB to debug a program that crashes. The set of GDB commands that we demonstrate in these two example sessions includes:

| Command | Description                                                                                                                   |
| ------- | ----------------------------------------------------------------------------------------------------------------------------- |
| `break` | Set a breakpoint                                                                                                              |
| `run`   | Start program running from the beginning                                                                                      |
| `cont`  | Continue execution of the program until it hits a breakpoint                                                                  |
| `quit`  | Quit the GDB session                                                                                                          |
| `next`  | Allow program to execute the next line of C code and then pause it                                                            |
| `step`  | Allow program to execute the next line of C code; if the next line contains a function call, step into the function and pause |
| `list`  | List C source code around pause point or specified point                                                                      |
| `print` | Print out the value of a program variable (or expression)                                                                     |
| `where` | Print the call stack                                                                                                          |
| `frame` | Move into the context of a specific stack frame                                                                               |

我们通过两个使用 GDB 调试程序的示例会话来演示 GDB 的常见功能。第一个是使用 GDB 查找并修复程序中的两个错误的示例，第二个是使用 GDB 调试崩溃的程序的示例。我们在这两个示例会话中演示的 GDB 命令集包括：  

| Command | 描述                                   |
| ------- | ------------------------------------ |
| `break` | 设置断点                                  
| `run`   |  启动程序从头开始运行                           
| `cont`  |  继续执行程序直到遇到断点                         
| `quit`  |  退出 GDB 会话                            
| `next`  |  允许程序执行下一行 C 代码，然后暂停                  
| `step`  |  允许程序执行下一行C代码；如果下一行包含函数调用，则单步执行该函数并暂停 
| `list`  |  列出暂停点或指定点周围的 C 源代码                   
| `print` |  打印出程序变量（或表达式）的值                      
| `where` |  打印调用栈                                
| `frame` |  移至特定栈帧的上下文                           

#### 使用 GDB 调试程序的示例 (badprog.c)

The first example GDB session debugs the [badprog.c](https://diveintosystems.org/book/C3-C_debug/_attachments/badprog.c) program. This program is supposed to find the largest value in an array of `int` values. However, when run, it incorrectly finds that 17 is the largest value in the array instead of the correct largest value, which is 60. This example shows how GDB can examine the program’s runtime state to determine why the program is not computing the expected result. In particular, this example debugging session reveals two bugs:

1. An error with loop bounds resulting in the program accessing elements beyond the bounds of the array.
    
2. An error in a function not returning the correct value to its caller.
    
第一个示例 GDB 会话调试 [badprog.c](https://diveintosystems.org/book/C3-C_debug/_attachments/badprog.c) 程序。该程序应该找到`int`值数组中的最大值。但是，运行时，它错误地发现 17 是数组中的最大值，而不是正确的最大值 60。此示例显示 GDB 如何检查程序的运行时状态以确定程序未计算预期结果的原因。特别是，此示例调试会话揭示了两个错误：  

1. 循环边界错误导致程序访问超出数组边界的元素。
2. 函数中的错误未向其调用者返回正确的值。

To examine a program with GDB, first compile the program with `-g` to add debugging information to the executable:

$ gcc -g badprog.c

要使用 GDB 检查程序，首先使用“-g”编译程序以将调试信息添加到可执行文件：

```bash
$ gcc -g badprog.c
```

Next, run GDB on the binary executable program (`a.out`). GDB initializes and prints the `(gdb)` prompt, where the user can enter GDB commands:

$ gdb ./a.out

GNU gdb (Ubuntu 8.1-0ubuntu3) 8.1.0.20180409-git
Copyright (C) 2018 Free Software Foundation, Inc.
  ...
(gdb)

接下来，在二进制可执行程序（`a.out`）上运行 GDB。 GDB 初始化并打印`(gdb)`提示，用户可以在其中输入 GDB 命令：

```
$ gdb ./a.out

GNU gdb (Ubuntu 8.1-0ubuntu3) 8.1.0.20180409-git
Copyright (C) 2018 Free Software Foundation, Inc.
  ...
(gdb)
```

At this point GDB has not yet started running the program. A common first debugging step is to set a breakpoint in the `main()` function to pause the program’s execution right before it executes the first instruction in `main()`. The `break` command sets a "breakpoint" (pauses the program) at a specified location (in this case at the start of the `main()` function):

(gdb) break main

Breakpoint 1 at 0x8048436: file badprog.c, line 36.

此时GDB还没有开始运行程序。常见的第一个调试步骤是在`main()`函数中设置断点，以在执行`main()`中的第一条指令之前暂停程序的执行。 `break` 命令在指定位置（在本例中是在 `main()` 函数的开头）设置一个`“断点”`（暂停程序）：  

```bash
(gdb) break main

Breakpoint 1 at 0x8048436: file badprog.c, line 36.
```

The `run` command tells GDB to start the program:

(gdb) run
Starting program: ./a.out

`run` 命令告诉 GDB 启动程序：

```
(gdb) run
Starting program: ./a.out
```

If the program takes command line arguments, provide them after the `run` command (for example, `run 100 200` would run `a.out` with the command line arguments `100` and `200`).  
如果程序需要命令行参数，请在`run`命令之后提供它们（例如，`run 100 200`将使用命令行参数`100`和`200`运行`a.out`）。

After entering `run`, GDB starts the program’s execution at its beginning, and it runs until it hits a breakpoint. Upon reaching a breakpoint, GDB pauses the program before executing the line of code at the breakpoint, and prints out the breakpoint number and source code line associated with the breakpoint. In this example, GDB pauses the program just before executing line 36 of the program. It then prints out the `(gdb)` prompt and waits for further instructions:

Breakpoint 1, main (argc=1, argv=0x7fffffffe398) at badprog.c:36
36     int main(int argc, char *argv[]) {

(gdb)

输入`run`后，GDB 从头开始​​执行程序，一直运行到遇到断点为止。到达断点时，GDB 在执行断点处的代码行之前暂停程序，并打印出断点编号和与断点相关的源代码行。在此示例中，GDB 在执行程序的第 36 行之前暂停程序。然后它会打印出`(gdb)`提示并等待进一步的指示：

```bash
Breakpoint 1, main (argc=1, argv=0x7fffffffe398) at badprog.c:36
36     int main(int argc, char *argv[]) {

(gdb)
```

Often when a program pauses at a breakpoint, the user wants to see the C source code around the breakpoint. The GDB `list` command displays the code surrounding the breakpoint:

(gdb) list
29	    }
30	    return 0;
31	}
32
33	/***************************************/
34	int main(int argc, char *argv[]) {
35
36	    int arr[5] = { 17, 21, 44, 2, 60 };
37
38	    int max = arr[0];

通常，当程序在断点处暂停时，用户希望查看断点周围的 C 源代码。 GDB的`list`命令显示断点周围的代码：

```bash
(gdb) list
29	    }
30	    return 0;
31	}
32
33	/***************************************/
34	int main(int argc, char *argv[]) {
35
36	    int arr[5] = { 17, 21, 44, 2, 60 };
37
38	    int max = arr[0];

```

Subsequent calls to `list` display the next lines of source code following these. `list` can also be used with a specific line number (for example, `list 11`) or with a function name to list the source code at a specified part of the program. For example:  

(gdb) list findAndReturnMax
12	 * 	array: array of integer values
13	 * 	len: size of the array
14	 * 	max: set to the largest value in the array
15	 *  	returns: 0 on success and non-zero on an error
16	 */
17	int findAndReturnMax(int *array1, int len, int max) {
18
19	    int i;
20
21	    if (!array1 || (len <=0) ) {

对 list 的后续调用将显示这些代码之后的下一行源代码。 list 还可以与特定行号(例如，`list 11`)或函数名称一起使用，以列出程序指定部分的源代码。例如：
```bash
(gdb) list findAndReturnMax
12	 * 	array: array of integer values
13	 * 	len: size of the array
14	 * 	max: set to the largest value in the array
15	 *  	returns: 0 on success and non-zero on an error
16	 */
17	int findAndReturnMax(int *array1, int len, int max) {
18
19	    int i;
20
21	    if (!array1 || (len <=0) ) {
```

The user may want to execute one line of code at a time after hitting a breakpoint, examining program state after each line is executed. The GDB `next` command executes just the very next line of C code. After the program executes this line of code, GDB pauses the program again. The `print` command prints the values of program variables. Here are a few calls to `next` and `print` to show their effects on the next two lines of execution. Note that the source code line listed after a `next` has not yet been executed — it shows the line where the program is paused, which represents the line that will be executed next:

(gdb) next
36	  int arr[5] = { 17, 21, 44, 2, 60 };
(gdb) next
38	  int max = arr[0];
(gdb) print max
$3 = 0
(gdb) print arr[3]
$4 = 2
(gdb) next
40	  if ( findAndReturnMax(arr, 5, max) != 0 ) {
(gdb) print max
$5 = 17
(gdb)

用户可能希望在命中断点后一次执行一行代码，并在执行每一行后检查程序状态。 GDB的`next`命令仅执行下一行 C 代码。程序执行完这行代码后，GDB再次暂停程序。 `print` 命令打印程序变量的值。以下是对`next`和`print`的一些调用，以显示它们对接下来两行执行的影响。请注意，`next`后面列出的源代码行尚未执行——它显示了程序暂停的行，它代表接下来将执行的行：

```bash
(gdb) next
36	  int arr[5] = { 17, 21, 44, 2, 60 };
(gdb) next
38	  int max = arr[0];
(gdb) print max
$3 = 0
(gdb) print arr[3]
$4 = 2
(gdb) next
40	  if ( findAndReturnMax(arr, 5, max) != 0 ) {
(gdb) print max
$5 = 17
(gdb)
```

At this point in the program’s execution, the main function has initialized its local variables `arr` and `max` and is about to make a call to the `findAndReturnMax()` function. The GDB `next` command executes the next full line of C source code. If that line includes a function call, the full execution of that function call and its return is executed as part of a single `next` command. A user who wants to observe the execution of the function should issue GDB’s `step` command instead of the `next` command: `step` steps into a function call, pausing the program before the first line of the function is executed.  
此时，在程序执行过程中，主函数已初始化其局部变量`arr`和`max`，并即将调用`findAndReturnMax()`函数。 GDB的`next`命令执行下一个完整的 C 源代码行。如果该行包含函数调用，则该函数调用的完整执行及其返回将作为单个`next`命令的一部分执行。想要观察函数执行情况的用户应该发出 GDB 的`step`命令，而不是`next`命令：`step`进入函数调用，在执行函数的第一行之前暂停程序。

Because we suspect that the bug in this program is related to the `findAndReturnMax()` function, we want to step into the function’s execution rather than past it. So, when paused at line 40, the `step` command will next pause the program at the start of the `findAndReturnMax()` (alternately, the user could set a breakpoint at `findAndReturnMax()` to pause the program’s execution at that point):

(gdb) next
40	  if ( findAndReturnMax(arr, 5, max) != 0 ) {
(gdb) step
findAndReturnMax (array1=0x7fffffffe290, len=5, max=17) at badprog.c:21
21	  if (!array1 || (len <=0) ) {
(gdb)

因为我们怀疑该程序中的错误与`findAndReturnMax()`函数有关，所以我们希望单步执行该函数而不是跳过它。因此，当在第 40 行暂停时，`step`命令接下来将在`findAndReturnMax()`开始处暂停程序(或者，用户可以在`findAndReturnMax()`处设置一个断点，以在该处暂停程序的执行观点)：

```bash
(gdb) next
40	  if ( findAndReturnMax(arr, 5, max) != 0 ) {
(gdb) step
findAndReturnMax (array1=0x7fffffffe290, len=5, max=17) at badprog.c:21
21	  if (!array1 || (len <=0) ) {
(gdb)
```

The program is now paused inside the `findAndReturnMax` function, whose local variables and parameters are now in scope. The `print` command shows their values, and `list` displays the C source code around the pause point:

(gdb) print array1[0]
$6 = 17
(gdb) print max
$7 = 17
(gdb) list
16	 */
17	int findAndReturnMax(int *array1, int len, int max) {
18
19	    int i;
20
21	    if (!array1 || (len <=0) ) {
22	        return -1;
23	    }
24	    max = array1[0];
25	    for (i=1; i <= len; i++) {
(gdb) list
26	        if(max < array1[i]) {
27	            max = array1[i];
28	        }
29	    }
30	    return 0;
31	}
32
33	/***************************************/
34	int main(int argc, char *argv[]) {
35

程序现在暂停在`findAndReturnMax`函数内，其局部变量和参数现在在范围内。 `print`命令显示它们的值，`list`显示暂停点周围的 C 源代码：  

```bash
(gdb) print array1[0]
$6 = 17
(gdb) print max
$7 = 17
(gdb) list
16	 */
17	int findAndReturnMax(int *array1, int len, int max) {
18
19	    int i;
20
21	    if (!array1 || (len <=0) ) {
22	        return -1;
23	    }
24	    max = array1[0];
25	    for (i=1; i <= len; i++) {
(gdb) list
26	        if(max < array1[i]) {
27	            max = array1[i];
28	        }
29	    }
30	    return 0;
31	}
32
33	/***************************************/
34	int main(int argc, char *argv[]) {
35
```

Because we think there is a bug related to this function, we may want to set a breakpoint inside the function so that we can examine the runtime state part way through its execution. In particular, setting a breakpoint on the line when `max` is changed may help us see what this function is doing.  
因为我们认为存在与该函数相关的错误，所以我们可能需要在该函数内部设置一个断点，以便我们可以在其执行过程中检查运行时状态。特别是，当`max`更改时在行上设置断点可以帮助我们了解该函数正在做什么。

We can set a breakpoint at a specific line number in the program (line 27) and use the `cont` command to tell GDB to let the application’s execution continue from its paused point. Only when the program hits a breakpoint will GDB pause the program and grab control again, allowing the user to enter other GDB commands.

(gdb) break 27
Breakpoint 2 at 0x555555554789: file badprog.c, line 27.

(gdb) cont
Continuing.

Breakpoint 2, findAndReturnMax (array1=0x...e290,len=5,max=17) at badprog.c:27
27	      max = array1[i];
(gdb) print max
$10 = 17
(gdb) print i
$11 = 1

我们可以在程序中的特定行号(第 27 行)设置断点，并使用`cont`命令告诉 GDB 让应用程序从暂停点继续执行。只有当程序遇到断点时，GDB才会暂停程序并再次获取控制权，允许用户输入其他GDB命令。

```bash
(gdb) break 27
Breakpoint 2 at 0x555555554789: file badprog.c, line 27.

(gdb) cont
Continuing.

Breakpoint 2, findAndReturnMax (array1=0x...e290,len=5,max=17) at badprog.c:27
27	      max = array1[i];
(gdb) print max
$10 = 17
(gdb) print i
$11 = 1
```

The `display` command asks GDB to automatically print out the same set of program variables every time a breakpoint is hit. For example, we will display the values of `i`, `max`, and `array1[i]` every time the program hits a breakpoint (in each iteration of the loop in `findAndReturnMax()`):

(gdb) display i
1: i = 1
(gdb) display max
2: max = 17
(gdb) display array1[i]
3: array1[i] = 21

(gdb) cont
Continuing.

Breakpoint 2, findAndReturnMax (array1=0x7fffffffe290, len=5, max=21)
    at badprog.c:27
27	      max = array1[i];
1: i = 2
2: max = 21
3: array1[i] = 44

(gdb) cont
Continuing.

Breakpoint 2, findAndReturnMax (array1=0x7fffffffe290, len=5, max=21)
    at badprog.c:27
27	      max = array1[i];
1: i = 3
2: max = 44
3: array1[i] = 2

(gdb) cont

Breakpoint 2, findAndReturnMax (array1=0x7fffffffe290, len=5, max=44)
    at badprog.c:27
27	      max = array1[i];
1: i = 4
2: max = 44
3: array1[i] = 60

(gdb) cont
Breakpoint 2, findAndReturnMax (array1=0x7fffffffe290, len=5, max=60)
    at badprog.c:27
27	      max = array1[i];
1: i = 5
2: max = 60
3: array1[i] = 32767

(gdb)

`display`命令要求 GDB 在每次遇到断点时自动打印出同一组程序变量。例如，每次程序遇到断点时(在`findAndReturnMax()`循环的每次迭代中)，我们都会显示`i`、`max`和`array1[i]`的值：  

```
(gdb) display i
1: i = 1
(gdb) display max
2: max = 17
(gdb) display array1[i]
3: array1[i] = 21

(gdb) cont
Continuing.

Breakpoint 2, findAndReturnMax (array1=0x7fffffffe290, len=5, max=21)
    at badprog.c:27
27	      max = array1[i];
1: i = 2
2: max = 21
3: array1[i] = 44

(gdb) cont
Continuing.

Breakpoint 2, findAndReturnMax (array1=0x7fffffffe290, len=5, max=21)
    at badprog.c:27
27	      max = array1[i];
1: i = 3
2: max = 44
3: array1[i] = 2

(gdb) cont

Breakpoint 2, findAndReturnMax (array1=0x7fffffffe290, len=5, max=44)
    at badprog.c:27
27	      max = array1[i];
1: i = 4
2: max = 44
3: array1[i] = 60

(gdb) cont
Breakpoint 2, findAndReturnMax (array1=0x7fffffffe290, len=5, max=60)
    at badprog.c:27
27	      max = array1[i];
1: i = 5
2: max = 60
3: array1[i] = 32767

(gdb)
```

We found our first bug! The value of `array1[i]` is 32767, a value not in the passed array, and the value of `i` is 5, but 5 is not a valid index into this array. Through GDB we discovered that the `for` loop bounds need to be fixed to `i < len`.  
我们发现了第一个错误！ `array1[i]` 的值为 32767，该值不在传递的数组中，而 `i` 的值为 5，但 5 不是该数组的有效索引。通过 GDB，我们发现`for`循环边界需要固定为`i < len`。

At this point, we could exit the GDB session and fix this bug in the code. To quit a GDB session, type `quit`:

(gdb) quit
The program is running.  Exit anyway? (y or n) y
$

此时，我们可以退出 GDB 会话并修复代码中的此错误。要退出 GDB 会话，请输入`quit`：  

```
(gdb) quit
The program is running.  Exit anyway? (y or n) y
$
```

After fixing this bug, recompiling, and running the program, it still does not find the correct max value (it still finds that 17 is the max value and not 60). Based on our previous GDB run, we may suspect that there is an error in calling or returning from the `findAndReturnMax()` function. We re-run the new version of our program in GDB, this time setting a breakpoint at the entry to the `findAndReturnMax()` function:

$ gdb ./a.out
...
(gdb) break main
Breakpoint 1 at 0x7c4: file badprog.c, line 36.

(gdb) break findAndReturnMax
Breakpoint 2 at 0x748: file badprog.c, line 21.

(gdb) run
Starting program: ./a.out

Breakpoint 1, main (argc=1, argv=0x7fffffffe398) at badprog.c:36
36	int main(int argc, char *argv[]) {
(gdb) cont
Continuing.

Breakpoint 2, findAndReturnMax (array1=0x7fffffffe290, len=5, max=17)
    at badprog.c:21
21	  if (!array1 || (len <=0) ) {
(gdb)

修复此错误后，重新编译并运行程序，它仍然找不到正确的最大值(它仍然发现 17 是最大值，而不是 60)。根据我们之前的 GDB 运行，我们可能怀疑调用`findAndReturnMax()`函数或返回时出现错误。我们在 GDB 中重新运行新版本的程序，这次在`findAndReturnMax()`函数的入口处设置一个断点：  

```
$ gdb ./a.out
...
(gdb) break main
Breakpoint 1 at 0x7c4: file badprog.c, line 36.

(gdb) break findAndReturnMax
Breakpoint 2 at 0x748: file badprog.c, line 21.

(gdb) run
Starting program: ./a.out

Breakpoint 1, main (argc=1, argv=0x7fffffffe398) at badprog.c:36
36	int main(int argc, char *argv[]) {
(gdb) cont
Continuing.

Breakpoint 2, findAndReturnMax (array1=0x7fffffffe290, len=5, max=17)
    at badprog.c:21
21	  if (!array1 || (len <=0) ) {
(gdb)
```

If we suspect a bug in the arguments or return value of a function, it may be helpful to examine the contents of the stack. The `where` (or `bt`, for "backtrace") GDB command prints the current state of the stack. In this example, the `main()` function is on the bottom of the stack (in frame 1) and is executing a call to `findAndReturnMax()` at line 40. The `findAndReturnMax()` function is on the top of the stack (in frame 0), and is currently paused at line 21:

(gdb) where
#0  findAndReturnMax (array1=0x7fffffffe290, len=5, max=17) at badprog.c:21
#1  0x0000555555554810 in main (argc=1, argv=0x7fffffffe398) at badprog.c:40

如果我们怀疑函数的参数或返回值存在错误，检查堆栈的内容可能会有所帮助。 `where`(或`bt`，表示"backtrace")GDB 命令打印堆栈的当前状态。在此示例中，`main()`函数位于栈底部(在第 1 帧中)，并在第 40 行执行对`findAndReturnMax()`的调用。`findAndReturnMax()`函数位于栈的顶部堆栈(在第 0 帧中)，当前暂停在第 21 行：  

```bash
(gdb) where
#0  findAndReturnMax (array1=0x7fffffffe290, len=5, max=17) at badprog.c:21
#1  0x0000555555554810 in main (argc=1, argv=0x7fffffffe398) at badprog.c:40
```

GDB’s `frame` command moves into the context of any frame on the stack. Within each stack frame context, a user can examine the local variables and parameters in that frame. In this example, we move into stack frame 1 (the caller’s context) and print out the values of the arguments that the `main()` function passes to `findAndReturnMax()` (for example, `arr` and `max`):

(gdb) frame 1
#1  0x0000555555554810 in main (argc=1, argv=0x7fffffffe398) at badprog.c:40
40	  if ( findAndReturnMax(arr, 5, max) != 0 ) {
(gdb) print arr
$1 = {17, 21, 44, 2, 60}
(gdb) print max
$2 = 17
(gdb)

GDB 的`frame`命令移动到栈上任何帧的上下文中。在每个栈帧上下文中，用户可以检查该帧中的局部变量和参数。在此示例中，我们进入堆栈帧 1(调用者的上下文)并打印出`main()`函数传递给`findAndReturnMax()`的参数值(例如`arr`和`max`) :

```bash
(gdb) frame 1
#1  0x0000555555554810 in main (argc=1, argv=0x7fffffffe398) at badprog.c:40
40	  if ( findAndReturnMax(arr, 5, max) != 0 ) {
(gdb) print arr
$1 = {17, 21, 44, 2, 60}
(gdb) print max
$2 = 17
(gdb)
```

The argument values look fine, so let’s check the `findAndReturnMax()` function’s return value. To do this, we add a breakpoint right before `findAndReturnMax()` returns to see what value it computes for its `max`:

(gdb) break 30
Breakpoint 3 at 0x5555555547ae: file badprog.c, line 30.
(gdb) cont
Continuing.

Breakpoint 3, findAndReturnMax (array1=0x7fffffffe290, len=5, max=60)
    at badprog.c:30
30	  return 0;

(gdb) print max
$3 = 60

参数值看起来不错，所以让我们检查一下`findAndReturnMax()`函数的返回值。为此，我们在`findAndReturnMax()`返回之前添加一个断点，以查看它计算出的`max`值：

```bash
(gdb) break 30
Breakpoint 3 at 0x5555555547ae: file badprog.c, line 30.
(gdb) cont
Continuing.

Breakpoint 3, findAndReturnMax (array1=0x7fffffffe290, len=5, max=60)
    at badprog.c:30
30	  return 0;

(gdb) print max
$3 = 60
```

This shows that the function has found the correct max value (60). Let’s execute the next few lines of code and see what value the `main()` function receives:

(gdb) next
31	}
(gdb) next
main (argc=1, argv=0x7fffffffe398) at badprog.c:44
44	  printf("max value in the array is %d\n", max);

(gdb) where
#0  main (argc=1, argv=0x7fffffffe398) at badprog.c:44

(gdb) print max
$4 = 17

这表明该函数已找到正确的最大值 (60)。让我们执行接下来的几行代码，看看`main()`函数接收到什么值：  

```bash
(gdb) next
31	}
(gdb) next
main (argc=1, argv=0x7fffffffe398) at badprog.c:44
44	  printf("max value in the array is %d\n", max);

(gdb) where
#0  main (argc=1, argv=0x7fffffffe398) at badprog.c:44

(gdb) print max
$4 = 17
```

We found the second bug! The `findAndReturnMax()` function identifies the correct largest value in the passed array (60), but it doesn’t return that value back to the `main()` function. To fix this error, we need to either change `findAndReturnMax()` to return its value of `max` or add a "pass-by-pointer" parameter that the function will use to modify the value of the `main()` function’s `max` local variable.  
我们发现了第二个错误！ `findAndReturnMax()` 函数识别传递的数组 (60) 中正确的最大值，但它不会将该值返回给 `main()` 函数。要修复此错误，我们需要更改`findAndReturnMax()`以返回其值`max`，或者添加一个“传递指针”(pass-by-pointer)参数，该函数将使用该参数来修改`main()`的值函数的`max`局部变量。

#### 使用 GDB 调试崩溃的程序的示例 (segfaulter.c)

The second example GDB session (run on the [segfaulter.c](https://diveintosystems.org/book/C3-C_debug/_attachments/segfaulter.c) program) demonstrates how GDB behaves when a program crashes and how we can use GDB to help discover why the crash occurs.  
第二个示例 GDB 会话(在 [segfaulter.c](https://diveintosystems.org/book/C3-C_debug/_attachments/segfaulter.c) 程序上运行)演示了程序崩溃时 GDB 的行为以及我们如何使用GDB 帮助发现崩溃发生的原因。

In this example, we just run the `segfaulter` program in GDB and let it crash:

$ gcc -g -o segfaulter segfaulter.c
$ gdb ./segfaulter

(gdb) run
Starting program: ./segfaulter

Program received signal SIGSEGV, Segmentation fault.
0x00005555555546f5 in initfunc (array=0x0, len=100) at segfaulter.c:14
14	    array[i] = i;

在这个例子中，我们只是在 GDB 中运行`segfaulter`程序并让它崩溃：  

```bash
$ gcc -g -o segfaulter segfaulter.c
$ gdb ./segfaulter

(gdb) run
Starting program: ./segfaulter

Program received signal SIGSEGV, Segmentation fault.
0x00005555555546f5 in initfunc (array=0x0, len=100) at segfaulter.c:14
14	    array[i] = i;
```

As soon as the program crashes, GDB pauses the program’s execution at the point it crashes and grabs control. GDB allows a user to issue commands to examine the program’s runtime state at the point of the program crash, often leading to discovering why the program crashed and how to fix the cause of the crash. The GDB `where` and `list` commands are particularly useful for determining where a program crashes:

(gdb) where
#0 0x00005555555546f5 in initfunc (array=0x0, len=100) at segfaulter.c:14
#1 0x00005555555547a0 in main (argc=1, argv=0x7fffffffe378) at segfaulter.c:37

(gdb) list
9	int initfunc(int *array, int len) {
10
11	    int i;
12
13	    for(i=1; i <= len; i++) {
14	        array[i] = i;
15	    }
16	    return 0;
17	}
18

一旦程序崩溃，GDB 就会在程序崩溃时暂停程序的执行并夺取控制权。 GDB 允许用户在程序崩溃时发出命令来检查程序的运行时状态，通常可以发现程序崩溃的原因以及如何修复崩溃的原因。 GDB的`where`和`list`命令对于确定程序崩溃的位置特别有用：  

```bash
(gdb) where
#0 0x00005555555546f5 in initfunc (array=0x0, len=100) at segfaulter.c:14
#1 0x00005555555547a0 in main (argc=1, argv=0x7fffffffe378) at segfaulter.c:37

(gdb) list
9	int initfunc(int *array, int len) {
10
11	    int i;
12
13	    for(i=1; i <= len; i++) {
14	        array[i] = i;
15	    }
16	    return 0;
17	}
18
```

This output tells us that the program crashes on line 14, in the `initfunc()` function. Examining the values of the parameters and local variables on line 14 may tell us why it crashes:

(gdb) print i
$2 = 1
(gdb) print array[i]
Cannot access memory at address 0x4

此输出告诉我们程序在第 14 行`initfunc()`函数中崩溃。检查第 14 行的参数和局部变量的值可能会告诉我们崩溃的原因：

```bash
(gdb) print i
$2 = 1
(gdb) print array[i]
Cannot access memory at address 0x4
```

The value of `i` seems fine, but we see an error when trying to access index `i` of `array`. Let’s print out the value of `array` (the value of the base address of the array) to see if that tells us anything:

(gdb) print array
$3 = (int *) 0x0

`i` 的值看起来不错，但是当我们尝试访问 `array` 的索引 `i` 时，我们看到一个错误。让我们打印出`array`的值(数组基地址的值)，看看这是否告诉我们什么：  

```bash
(gdb) print array
$3 = (int *) 0x0
```

We have found the cause of the crash! The base address of the array is zero (or `NULL`), and we know that dereferencing a null pointer (via `array[i]`) causes programs to crash.  
我们已经找到事故原因了！数组的基地址为零(或`NULL`)，我们知道取消引用空指针(通过`array[i]`)会导致程序崩溃。

Let’s see if we can figure out why the `array` parameter is `NULL` by looking in the caller’s stack frame:

(gdb) frame 1
#1 0x00005555555547a0 in main (argc=1, argv=0x7fffffffe378) at segfaulter.c:37
37	  if(initfunc(arr, 100) != 0 ) {
(gdb) list
32	int main(int argc, char *argv[]) {
33
34	    int *arr = NULL;
35	    int max = 6;
36
37	    if(initfunc(arr, 100) != 0 ) {
38	        printf("init error\n");
39	        exit(1);
40	    }
41
(gdb) print arr
$4 = (int *) 0x0
(gdb)

让我们看看是否可以通过查看调用者的堆栈帧来找出为什么`array`参数为`NULL`：

```bash
(gdb) frame 1
#1 0x00005555555547a0 in main (argc=1, argv=0x7fffffffe378) at segfaulter.c:37
37	  if(initfunc(arr, 100) != 0 ) {
(gdb) list
32	int main(int argc, char *argv[]) {
33
34	    int *arr = NULL;
35	    int max = 6;
36
37	    if(initfunc(arr, 100) != 0 ) {
38	        printf("init error\n");
39	        exit(1);
40	    }
41
(gdb) print arr
$4 = (int *) 0x0
(gdb)
```

Moving into the caller’s stack frame and printing out the value of the arguments `main()` passes to `initfunc()` shows that the `main()` function passes a null pointer to the `initfunc()` function. In other words, the user forgot to allocate the `arr` array prior to the call to `initfunc()`. The fix is to use the `malloc()` function to allocate some space to `arr` at line 34.  
进入调用者的堆栈帧并打印出`main()`传递给`initfunc()`参数的值，表明`main()`函数向`initfunc()`函数传递了一个空指针。换句话说，用户忘记在调用`initfunc()`之前分配`arr`数组。解决方法是使用`malloc()`函数为第 34 行的`arr`分配一些空间。

These two example GDB sessions illustrate commonly used commands for finding bugs in programs. In the next section, we discuss these and other GDB commands in more detail.  
这两个示例 GDB 会话说明了查找程序中错误的常用命令。在下一节中，我们将更详细地讨论这些命令和其他 GDB 命令。
